"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgithub_io_demo"] = self["webpackChunkgithub_io_demo"] || []).push([["vendors-node_modules__magic_drag_1_2_7_magic_drag_lib_magic_drag-esm_js"],{

/***/ "./node_modules/_magic_drag@1.2.7@magic_drag/lib/magic_drag-esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/_magic_drag@1.2.7@magic_drag/lib/magic_drag-esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMagicDrag: () => (/* binding */ useMagicDrag),\n/* harmony export */   useMagicList: () => (/* binding */ useMagicList),\n/* harmony export */   useMoveElement: () => (/* binding */ useMoveElement)\n/* harmony export */ });\n/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ \"./node_modules/_@vue_reactivity@3.4.19@@vue/reactivity/dist/reactivity.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/_@vue_runtime-core@3.4.19@@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n\n\n\nfunction throttle(fn, delay, options = {}) {\n    let { leading = false } = options;\n    let flag = true;\n    return (...rest) => {\n        if (!flag)\n            return;\n        if (leading) {\n            fn(...rest);\n            leading = false;\n        }\n        flag = false;\n        setTimeout(() => {\n            fn(...rest);\n            flag = true;\n        }, delay);\n    };\n}\nfunction notSelectorAndHTML(value) {\n    return typeof value !== 'string' && !(value instanceof HTMLElement);\n}\nfunction getElement(ele) {\n    if (typeof ele === 'string') {\n        return document.querySelector(ele);\n    }\n    return ele;\n}\n// 合并对象，优先使用source的字段\nfunction mergeObject(target, source, ...rest) {\n    if (!source)\n        return { ...target };\n    const mergedObject = {};\n    for (const key in { ...target, ...source }) {\n        const curVal = source[key];\n        const originVal = target[key];\n        isNullOrUndefined(curVal)\n            ? mergedObject[key] = originVal\n            : mergedObject[key] = curVal;\n        if (typeof curVal === 'object' && !(curVal instanceof HTMLElement) && !Array.isArray(curVal)) {\n            mergedObject[key] = mergeObject(originVal, curVal);\n        }\n    }\n    return mergedObject;\n}\nfunction isNullOrUndefined(val) {\n    return val === null || val === undefined;\n}\nfunction conditionExecute(condition, result1, result2) {\n    if (isNullOrUndefined(result2))\n        return condition && result1;\n    return condition ? result1 : result2;\n}\nfunction removeElements(elements) {\n    if (Array.isArray(elements)) {\n        elements.forEach(ele => {\n            ele.remove();\n        });\n    }\n    else {\n        for (const key in elements) {\n            elements[key].remove();\n        }\n    }\n    elements = null;\n}\nfunction baseErrorTips(condition, msg) {\n    if (condition)\n        throw Error(msg);\n}\nfunction baseWarnTips(condition, msg) {\n    if (condition)\n        console.warn(msg);\n}\nconst setStyle = (target, styleKey, styleValue) => {\n    if (typeof styleKey === 'object') {\n        const keys = Object.keys(styleKey);\n        keys.forEach(key => {\n            target.style[key] = styleKey[key];\n        });\n        return;\n    }\n    target.style[styleKey] = styleValue;\n};\n// 将defaultAction的控制权交给callback\nfunction transferControl(defaultAction, callback, ...rest) {\n    callback ? callback(defaultAction, ...rest) : defaultAction();\n}\nfunction getObjectIntValue(object) {\n    const newObject = {};\n    for (const key in object) {\n        newObject[key] = parseInt(object[key]);\n    }\n    return newObject;\n}\nfunction appendChild(parent, ...child) {\n    parent.append(...child);\n}\nfunction addClassName(element, className) {\n    const isIncludeClassName = element.className.indexOf(` ${className} `) > -1;\n    if (!isIncludeClassName) {\n        element.className += ` ${className} `;\n    }\n}\n// 将number类型的尺寸信息改为以 px 为单位的字符串尺寸信息\nfunction numberToStringSize(size) {\n    const result = {};\n    for (const key in size) {\n        result[key] = size[key] + 'px';\n    }\n    return result;\n}\nfunction shuffleString(inputString) {\n    const charArray = inputString.split('');\n    for (let i = charArray.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [charArray[i], charArray[j]] = [charArray[j], charArray[i]];\n    }\n    return charArray.join('');\n}\nfunction generateID() {\n    const timestamp = shuffleString(Date.now().toString(16)); // 获取当前时间戳\n    const randomPart = Math.random() * 100000; // 生成随机数部分\n    return `${timestamp}${randomPart.toFixed(0)}`;\n}\nfunction memoize(fn) {\n    if (!fn.name) {\n        console.warn('Anonymous functions cannot be taken as arguments');\n        return fn;\n    }\n    const cache = {};\n    return function () {\n        if (cache[fn.name])\n            return cache[fn.name];\n        cache[fn.name] = fn();\n        return cache[fn.name];\n    };\n}\nfunction resetObject(raw, value = '') {\n    const result = {};\n    for (const key in raw) {\n        result[key] = value;\n    }\n    return result;\n}\n\nlet resizeTasks = [];\nfunction executeTasks(event) {\n    resizeTasks.forEach(task => task(event));\n}\nwindow.addEventListener('resize', executeTasks);\n\nconst resolvePromise = Promise.resolve();\nfunction nextTick(cb) {\n    return resolvePromise.then(cb);\n}\nfunction useWatchData(data, cb) {\n    return new Proxy(data, {\n        get(target, p, receiver) {\n            return target[p];\n        },\n        set(target, p, newValue, receiver) {\n            target[p] = newValue;\n            cb();\n            return true;\n        }\n    });\n}\n\nfunction guaranteeAbsolute(el) {\n    return getComputedStyle(el).position === 'absolute'\n        ? null\n        : el.style.position = 'absolute';\n}\nfunction useMoveElement(selector, callback = () => { }, moveOption = {}) {\n    const { limitDirection, throttleTime = 10, offsetLeft = 0, offsetTop = 0 } = moveOption;\n    let moveCallback, downCallback, upCallback;\n    if (callback && typeof callback === 'function') {\n        moveCallback = callback;\n    }\n    else if (callback && typeof callback === 'object') {\n        moveCallback = callback.move;\n        downCallback = callback.down;\n        upCallback = callback.up;\n    }\n    baseWarnTips(throttleTime >= 100, 'the throttleTime is greater than 100 and the visual effects may not be smooth');\n    nextTick(initElement);\n    let $ele;\n    // 鼠标状态\n    const isPress = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\n    // 按下鼠标时鼠标的坐标\n    const startOffset = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)({\n        x: 0,\n        y: 0\n    });\n    // 按下鼠标时元素的坐标\n    const startCoordinate = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)({\n        x: 0,\n        y: 0\n    });\n    // 元素移动的距离\n    const movement = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)({\n        x: 0,\n        y: 0\n    });\n    // 相对容器元素变化的偏移量\n    const relativeContainer = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)({\n        x: 0,\n        y: 0\n    });\n    const throttleMouseMove = throttle(mouseMove, 10, { leading: true });\n    const watchMovement = useWatchData(movement, updatePosition);\n    function initElement() {\n        $ele = getElement(selector);\n        guaranteeAbsolute($ele);\n        $ele.addEventListener('mousedown', mouseDown);\n    }\n    function mouseUp(event) {\n        const upAction = () => {\n            changePress(false);\n        };\n        // 如果有回调将控制权交给回调，否则执行默认动作\n        upCallback ? transferControl(upAction, upCallback, event) : upAction();\n    }\n    function mouseDown(event) {\n        event.preventDefault();\n        const downAction = () => {\n            changePress(true);\n            // 初始化鼠标移动的距离\n            setMovement({ x: 0, y: 0 });\n            // 更新计算元素的坐标\n            setStartCoordinate({ x: $ele.offsetLeft, y: $ele.offsetTop });\n            // 更新鼠标的坐标\n            setStartOffset({ x: event.pageX, y: event.pageY });\n            window.addEventListener('mousemove', throttleMouseMove);\n            window.addEventListener('mouseup', mouseUp);\n        };\n        // 如果有回调将控制权交给回调，否则执行默认动作\n        downCallback ? transferControl(downAction, downCallback, event) : downAction();\n    }\n    function mouseMove(event) {\n        if (!isPress.value)\n            return;\n        function moveAction() {\n            event.preventDefault();\n            // 如果有限制移动，则不更新movement和元素坐标\n            isUpdateMovementX() && setMovement({ x: event.pageX - startOffset.x });\n            isUpdateMovementY() && setMovement({ y: event.pageY - startOffset.y });\n            arriveLeftBound() && setMovement({ x: offsetLeft - startCoordinate.x });\n            arriveTopBound() && setMovement({ y: offsetTop - startCoordinate.y });\n            updatePosition();\n        }\n        transferControl(moveAction, moveCallback, watchMovement, event);\n    }\n    function destroy() {\n        $ele.removeEventListener('mousedown', mouseDown);\n        window.removeEventListener('mousemove', throttleMouseMove);\n        window.removeEventListener('mouseup', mouseUp);\n        $ele = null;\n    }\n    return {\n        mouseX: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(() => startOffset.x - startCoordinate.x),\n        mouseY: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(() => startOffset.y - startCoordinate.y),\n        left: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(startCoordinate, 'x'),\n        top: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(startCoordinate, 'y'),\n        movementX: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(watchMovement, 'x'),\n        movementY: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(watchMovement, 'y'),\n        relContainerX: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(relativeContainer, 'x'),\n        relContainerY: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(relativeContainer, 'y'),\n        isPress: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly)(isPress),\n        destroy\n    };\n    function updatePosition() {\n        $ele.style.left = startCoordinate.x + movement.x + 'px';\n        $ele.style.top = startCoordinate.y + movement.y + 'px';\n    }\n    function changePress(newStatus) {\n        isPress.value = newStatus;\n    }\n    function setMovement({ x, y }) {\n        movement.x = x ?? movement.x;\n        movement.y = y ?? movement.y;\n    }\n    function setStartOffset({ x, y }) {\n        startOffset.x = x;\n        startOffset.y = y;\n    }\n    function setStartCoordinate({ x, y }) {\n        startCoordinate.x = x;\n        startCoordinate.y = y;\n    }\n    function isUpdateMovementX() {\n        return limitDirection !== 'X';\n    }\n    function isUpdateMovementY() {\n        return limitDirection !== 'Y';\n    }\n    function arriveLeftBound() {\n        return startCoordinate.x + movement.x < offsetLeft;\n    }\n    function arriveTopBound() {\n        return startCoordinate.y + movement.y < offsetTop;\n    }\n}\n\nconst MAGIC_DRAG = 'magic_drag';\nfunction addPrefix(className) {\n    return ` ${MAGIC_DRAG}-${className}`;\n}\nconst ClassName = {\n    OutlinePoint: addPrefix('outline_point'), // 轮廓点的类名\n    // MenuBox : addPrefix('menu_box'), // menuBox类名\n    ContainerClassName: addPrefix('menu_container'), // 菜单的类名\n    ItemClassName: addPrefix('menu_item'), // 菜单选项的类名\n    LockItemClassName: addPrefix('menu_item-lock'), // 锁定的菜单选项的类名\n    LockTargetClassName: addPrefix('target-lock'), // 锁定的目标元素的类名\n};\nvar TargetStatus;\n(function (TargetStatus) {\n    TargetStatus[TargetStatus[\"Normal\"] = 55555] = \"Normal\";\n    TargetStatus[TargetStatus[\"Checked\"] = 77777] = \"Checked\";\n    TargetStatus[TargetStatus[\"Locked\"] = 44444] = \"Locked\";\n    TargetStatus[TargetStatus[\"Uppermost\"] = 66666] = \"Uppermost\";\n    TargetStatus[TargetStatus[\"Lowest\"] = 33333] = \"Lowest\";\n})(TargetStatus || (TargetStatus = {}));\n// const zIndexRecord: Record<StatusType, number> = {\n//   [TargetStatus.Normal]: 0,\n//   [TargetStatus.Checked]: 0,\n//   [TargetStatus.Locked]: 0\n// }\nfunction getTargetZIndex(targetStatus, target) {\n    return targetStatus - Number(target.dataset.index);\n}\n\nclass PluginManager {\n    constructor() {\n        this._plugins = new Map();\n    }\n    get plugins() {\n        return new Map(this._plugins);\n    }\n    registerPlugin(name, plugin) {\n        this._plugins.set(name, plugin);\n    }\n    installPlugin() {\n        this.plugins.forEach(plugin => {\n            plugin.init();\n        });\n    }\n    uninstallPlugin() {\n        this.plugins.forEach(plugin => {\n            plugin.unbind();\n        });\n    }\n    // MARK 5.扩展点触发 - 在关键时刻触发扩展点，通知注册在该扩展点上的插件。\n    callExtensionPoint(extensionPoint, ...args) {\n        this.plugins.forEach((plugin) => {\n            if (typeof plugin[extensionPoint] === 'function') {\n                plugin[extensionPoint](...args);\n            }\n        });\n    }\n}\n/*\n* MARK 当设计插件机制时，可以遵循以下一般的工作流程：\n   定义接口或基类： 首先，你需要定义一个接口或基类，用于规定插件应该实现的方法或属性。这可以帮助确保插件遵循相同的结构和约定。\n   实现插件类： 创建实际的插件类，这些类应该继承自定义的接口或基类。插件类会包含特定的功能、操作或扩展。\n   注册插件： 在你的拖拽库中，你需要一个地方来注册插件。这可以是一个插件管理器或主类。在这里，你会实例化并管理所有的插件。\n   初始化插件： 在拖拽库初始化或启动时，你需要初始化所有已注册的插件。这可以通过调用插件的初始化方法来完成。\n   调用插件功能： 在适当的时候，你会调用已初始化的插件的特定方法，以实现额外的功能。这些方法可能在拖拽、缩放、点击等操作发生时被调用。\n   传递参数： 在调用插件的方法时，通常会将一些参数传递给插件。这些参数可以是关于拖拽元素、状态、位置等的信息，以便插件可以根据需要执行操作。\n   响应插件操作： 插件会执行其自身的逻辑，可能会修改拖拽元素的状态、位置或其他属性。\n   销毁插件： 在拖拽库的生命周期结束时，需要销毁所有已初始化的插件，以释放资源并执行必要的清理操作。\n   总的来说，插件机制的核心思想是将拖拽库的功能划分为模块化的插件，以便于灵活扩展和定制。每个插件负责一项特定的任务，\n   而库本身负责管理插件的初始化、调用和销毁。这种模式可以帮助保持库的可维护性和可扩展性，使新功能的添加更加简便。\n* */\n\nclass StateManager {\n    constructor() {\n        this._elementRecords = [];\n        this.selectedElement = null;\n        this.selectedState = null;\n        this.subscriptions = {};\n    }\n    /**\n     * 添加 DOM 元素的状态\n     * @param element 添加的DOM元素\n     * @param initialState DOM\n     * @param isSetSelected 是否设置为选中状态\n     */\n    registerElementState(element, initialState, isSetSelected = true) {\n        this._elementRecords.push({ element, state: initialState, options: {} });\n        isSetSelected && this.setCurrentElement(element);\n    }\n    // 获取 DOM 元素的状态\n    getStateByEle(element) {\n        const elementState = this._elementRecords.find((es) => es.element === element);\n        if (!elementState)\n            console.warn('元素未注册');\n        return elementState ? elementState.state : null;\n    }\n    setStateByEle(element, key, value) {\n        const ele = this._elementRecords.find(item => item.element === element);\n        if (ele && typeof value === 'object') {\n            const settingObj = ele.state[key];\n            for (const innerKey in value) {\n                if (!innerKey in settingObj)\n                    continue;\n                settingObj[innerKey] = value[innerKey];\n            }\n        }\n        else {\n            ele.state[key] = value;\n        }\n        this.notifySubscribers('selected', element, key, value);\n    }\n    insertState(element, state, options) {\n        this._elementRecords.push({\n            element, state, options\n        });\n    }\n    clear() {\n        this._elementRecords = [];\n        this.selectedState = null;\n        this.selectedElement = null;\n        this.subscriptions = {};\n    }\n    get allElement() {\n        return this.selectedState.allTarget;\n    }\n    get containerLeft() {\n        return this.currentState?.containerInfo?.offsetLeft || 0;\n    }\n    get containerTop() {\n        return this.currentState?.containerInfo?.offsetTop || 0;\n    }\n    get elementRecords() {\n        return this._elementRecords.slice();\n    }\n    get targetState() {\n        return this.currentState.targetState;\n    }\n    // 获取当前选中的 DOM 元素\n    get currentElement() {\n        return this.selectedElement;\n    }\n    // 获取当前选中的 DOM 元素的状态\n    get currentState() {\n        return this.selectedState;\n    }\n    get size() {\n        return this._elementRecords.length;\n    }\n    get regionSelectedState() {\n        return this._elementRecords.filter(record => record.state.regionSelected)\n            .map(m => m.state);\n    }\n    get regionSelectedElement() {\n        return this._elementRecords.filter(record => record.state.regionSelected)\n            .map(m => m.element);\n    }\n    // 当选中的元素个数大于1说明是多选操作\n    get isRegionSelection() {\n        return this.regionSelectedElement.length > 1;\n    }\n    // 设置当前选中的 DOM 元素和状态\n    setCurrentElement(element) {\n        this.selectedElement = element;\n        this.selectedState = this.getStateByEle(element); // 获取选中元素的状态\n        this.updatePublicTargetState(); // 更新公共状态\n    }\n    updatePublicTargetState() {\n        StateManager.COORDINATE_KEY.forEach(key => {\n            this.currentState.targetState[key] = this.currentState.coordinate[key];\n        });\n    }\n    // 订阅状态变化\n    subscribe(key, callback) {\n        if (!this.subscriptions[key]) {\n            this.subscriptions[key] = [];\n        }\n        this.subscriptions[key].push(callback);\n    }\n    // 取消订阅状态变化\n    unsubscribe(key, callback) {\n        if (this.subscriptions[key]) {\n            this.subscriptions[key] = this.subscriptions[key].filter((cb) => cb !== callback);\n        }\n    }\n    // 通知订阅者状态变化\n    notifySubscribers(type, element, key, value) {\n        if (this.subscriptions[type]) {\n            this.subscriptions[type]\n                .forEach((callback) => callback(element, key, value));\n        }\n    }\n}\nStateManager.COORDINATE_KEY = ['left', 'top', 'width', 'height'];\n\nconst stateManager = new StateManager();\nfunction setInitialState(target, initialState, isSelected) {\n    stateManager.registerElementState(target, initialState, isSelected);\n}\n\n/* strong correlation functional - 强相关的功能 */\n// each element represents the direction of a contour point\n// 每个元素代表一个轮廓点的方向\nconst All_DIRECTION = ['lt', 'lb', 'rt', 'rb', 'l', 'r', 't', 'b'];\n// obtains this point according to the direction of the contour point\n// 根据轮廓点的方向获取这个点的\nfunction getDirectionDescription(direction) {\n    const hasL = direction.indexOf('l') > -1;\n    const hasR = direction.indexOf('r') > -1;\n    const hasB = direction.indexOf('b') > -1;\n    const hasT = direction.indexOf('t') > -1;\n    return {\n        hasL,\n        hasR,\n        hasT,\n        hasB\n    };\n}\n// create a strategy to move each contour point to update the coordinates and dimensions of the target element\n// 创建移动各个轮廓点更新目标元素坐标与尺寸信息的策略\nfunction createCoordinateStrategies() {\n    const strategies = {};\n    All_DIRECTION.forEach(direction => {\n        const { hasT, hasR, hasB, hasL } = getDirectionDescription(direction);\n        strategies[direction] = ({ left, top, height, width, offsetX, offsetY }) => {\n            return {\n                left: conditionExecute(hasL, left + offsetX + 'px', left + 'px'),\n                top: conditionExecute(hasT, top + offsetY + 'px', top + 'px'),\n                width: conditionExecute(hasL, width - offsetX + 'px', conditionExecute(hasR, width + offsetX + 'px', width + 'px')),\n                height: conditionExecute(hasT, height - offsetY + 'px', conditionExecute(hasB, height + offsetY + 'px', height + 'px'))\n            };\n        };\n    });\n    return strategies;\n}\nconst memoizeCreateCoordinateStrategies = memoize(createCoordinateStrategies);\n/*\n* movementX/Y: 鼠标移动的距离\n* limitMinDistanceX/Y: 限制最小尺寸时可移动的最大距离\n* limitMaxDistanceX/Y: 限制最大尺寸时可移动的最大距离\n* */\n// 限制目标元素尺寸\nconst limitSizeTasks = {\n    left({ movementX, limitMinDistanceX, limitMaxDistanceX }) {\n        // 限制最小尺寸\n        movementX.value > limitMinDistanceX && (movementX.value = limitMinDistanceX);\n        // 限制最大尺寸\n        limitMaxDistanceX + movementX.value < 0 && (movementX.value = -limitMaxDistanceX);\n    },\n    right({ movementX, limitMinDistanceX, limitMaxDistanceX }) {\n        -movementX.value > limitMinDistanceX && (movementX.value = -limitMinDistanceX);\n        movementX.value > limitMaxDistanceX && (movementX.value = limitMaxDistanceX);\n    },\n    top({ movementY, limitMinDistanceY, limitMaxDistanceY }) {\n        movementY.value > limitMinDistanceY && (movementY.value = limitMinDistanceY);\n        limitMaxDistanceY + movementY.value < 0 && (movementY.value = -limitMaxDistanceY);\n    },\n    bottom({ movementY, limitMinDistanceY, limitMaxDistanceY }) {\n        -movementY.value > limitMinDistanceY && (movementY.value = -limitMinDistanceY);\n        movementY.value > limitMaxDistanceY && (movementY.value = limitMaxDistanceY);\n    }\n};\n// 限制目标元素的移动边界\nconst limitBoundaryTasks = {\n    left({ movementX, coordinate, containerInfo }) {\n        movementX.value + coordinate.left - containerInfo.paddingLeft <= 0 && (movementX.value = containerInfo.paddingLeft - coordinate.left);\n    },\n    right({ movementX, coordinate, containerInfo }) {\n        movementX.value + coordinate.left + coordinate.width >= containerInfo.width + containerInfo.paddingLeft &&\n            (movementX.value = containerInfo.width - coordinate.left - coordinate.width + containerInfo.paddingLeft);\n    },\n    top({ movementY, coordinate, containerInfo }) {\n        movementY.value + coordinate.top - containerInfo.paddingTop <= 0 && (movementY.value = containerInfo.paddingTop - coordinate.top);\n    },\n    bottom({ movementY, coordinate, containerInfo }) {\n        movementY.value + coordinate.top + coordinate.height >= containerInfo.height + containerInfo.paddingTop &&\n            (movementY.value = containerInfo.height - coordinate.top - coordinate.height + containerInfo.paddingTop);\n    }\n};\n// create a policy to limit the minimum size when resizing the target\n// 创建调整目标大小时限制最小尺寸的策略\nfunction createResizeLimitStrategies({ minWidth, minHeight, maxWidth, maxHeight }, { coordinate, containerInfo }) {\n    const strategies = {};\n    const leftTask = (movementX, limitMinDistanceX, limitMaxDistanceX) => {\n        limitSizeTasks.left({ movementX, limitMinDistanceX, limitMaxDistanceX });\n        limitBoundaryTasks.left({ movementX, coordinate, containerInfo });\n    };\n    const topTask = (movementY, limitMinDistanceY, limitMaxDistanceY) => {\n        limitSizeTasks.top({ movementY, limitMinDistanceY, limitMaxDistanceY });\n        limitBoundaryTasks.top({ movementY, coordinate, containerInfo });\n    };\n    const bottomTask = (movementY, limitMinDistanceY, limitMaxDistanceY) => {\n        limitSizeTasks.bottom({ movementY, limitMinDistanceY, limitMaxDistanceY });\n        limitBoundaryTasks.bottom({ movementY, coordinate, containerInfo });\n    };\n    const rightTask = (movementX, limitMinDistanceX, limitMaxDistanceX) => {\n        limitSizeTasks.right({ movementX, limitMinDistanceX, limitMaxDistanceX });\n        limitBoundaryTasks.right({ movementX, coordinate, containerInfo });\n    };\n    All_DIRECTION.forEach(direction => {\n        strategies[direction] = ({ movementX, movementY }) => {\n            const { width, height } = coordinate;\n            const { hasT, hasR, hasB, hasL } = getDirectionDescription(direction);\n            // the maximum distance that can be moved\n            const limitMinDistanceX = width - minWidth;\n            const limitMinDistanceY = height - minHeight;\n            const limitMaxDistanceX = maxWidth - width;\n            const limitMaxDistanceY = maxHeight - height;\n            hasL && leftTask(movementX, limitMinDistanceX, limitMaxDistanceX);\n            hasT && topTask(movementY, limitMinDistanceY, limitMaxDistanceY);\n            hasR && rightTask(movementX, limitMinDistanceX, limitMaxDistanceX);\n            hasB && bottomTask(movementY, limitMinDistanceY, limitMaxDistanceY);\n        };\n    });\n    return strategies;\n}\n// get the latest contour point coordinate policy after creating updated target dimensions/coordinates\n// 创建更新目标尺寸/坐标后获取最新的轮廓点坐标策略\nfunction createPositionStrategies() {\n    const strategies = {};\n    All_DIRECTION.forEach(direction => {\n        const { hasT, hasR, hasB, hasL } = getDirectionDescription(direction);\n        strategies[direction] = ({ left, top, width, height, movementX, movementY }) => {\n            return {\n                left: conditionExecute(hasL, left + movementX, left),\n                top: conditionExecute(hasT, top + movementY, top),\n                width: conditionExecute(hasL, width - movementX, conditionExecute(hasR, width + movementX, width)),\n                height: conditionExecute(hasT, height - movementY, conditionExecute(hasB, height + movementY, height))\n            };\n        };\n    });\n    return strategies;\n}\nconst memoizeCreatePositionStrategies = memoize(createPositionStrategies);\n// set element position\n// 设置元素坐标信息\nfunction setPosition(point, pointPosition, direction) {\n    setStyle(point, 'left', pointPosition[direction][0] + 'px');\n    setStyle(point, 'top', pointPosition[direction][1] + 'px');\n}\n// 根据目标元素的尺寸、位置信息和轮廓点尺寸生成各个轮廓点的位置信息\nfunction createParentPosition({ left, top, width, height }, pointSize) {\n    const halfPointSize = pointSize / 2;\n    return {\n        lt: [left - halfPointSize, top - halfPointSize, 'nw-resize'],\n        lb: [left - halfPointSize, top + height - halfPointSize, 'ne-resize'],\n        rt: [left + width - halfPointSize, top - halfPointSize, 'ne-resize'],\n        rb: [left + width - halfPointSize, top + height - halfPointSize, 'nw-resize'],\n        t: [left + width / 2 - halfPointSize, top - halfPointSize, 'n-resize', 'X'],\n        b: [left + width / 2 - halfPointSize, top + height - halfPointSize, 'n-resize', 'X'],\n        l: [left - halfPointSize, top + height / 2 - halfPointSize, 'e-resize', 'Y'],\n        r: [left + width - halfPointSize, top + height / 2 - halfPointSize, 'e-resize', 'Y']\n    };\n}\n// update state - 更新状态\nfunction updateState(state, keyOrState, value) {\n    if (typeof keyOrState === 'object') {\n        for (const targetKey in state) {\n            state[targetKey] = keyOrState[targetKey] ?? state[targetKey];\n        }\n    }\n    else {\n        state[keyOrState] = value;\n    }\n}\n/* moveTarget */\n// controls how elements are displayed and hidden\n// 控制元素的显示和隐藏\nfunction showOrHideContourPoint(pointElements, isShow) {\n    for (const key in pointElements) {\n        setStyle(pointElements[key], 'display', isShow ? 'block' : 'none');\n    }\n}\nfunction checkIsContains(target, pointElements, targetState, stateManager, event) {\n    const { coordinate, downPointPosition, pointState, options: { pointSize, skill }, allContainer, publicTarget, privateTarget } = stateManager.getStateByEle(target);\n    // 如果点击目标元素是容器则隐藏轮廓点\n    if ([...allContainer, document.body, document.documentElement].includes(event.target)) {\n        showOrHideContourPoint(pointElements, false);\n        // 隐藏轮廓点时让当前选中的元素的层级恢复到正常状态（因为锁定状态不能被选中，所以不需要判断锁定的状态）\n        privateTarget === publicTarget.value && setStyle(publicTarget.value, 'zIndex', getTargetZIndex(TargetStatus.Normal, publicTarget.value));\n    }\n    // 每注册一个元素，window就多绑定一个事件，点击时也会触发window绑定的其他元素对应的mousedown事件，\n    // 判断事件目标与绑定的元素是否相同，如果不同不响应操作\n    if (event.target !== target)\n        return;\n    // skill.resize关闭时不需要显示轮廓点，就不需要更新位置\n    const pointPosition = skill.resize && updatePointPosition({ direction: 't', movementX: 0, movementY: 0 }, { coordinate, pointElements, pointSize, pointState }, { excludeCurPoint: false, updateDirection: false });\n    // 更新downPointPosition\n    for (const pointKey in pointPosition) {\n        downPointPosition[pointKey] = [pointPosition[pointKey][0], pointPosition[pointKey][1]];\n    }\n    // outline points are displayed when in focus\n    // 聚焦时将显示轮廓点（多选的情况下不需要显示轮廓点）\n    showOrHideContourPoint(pointElements, !stateManager.isRegionSelection);\n    // 设置选中元素的层级\n    setStyle(target, 'zIndex', getTargetZIndex(TargetStatus.Checked, target));\n}\n// control the focus and out-of-focus display of the target element's outline points\n// 控制目标元素轮廓点的焦点和失焦显示\nfunction blurOrFocus(pointElements, targetState, stateManager) {\n    let checkIsContainsTarget;\n    return (target, isBind = true) => {\n        if (isBind) {\n            window.addEventListener('mousedown', checkIsContainsTarget ?? (checkIsContainsTarget = checkIsContains.bind(null, target, pointElements, targetState, stateManager)));\n        }\n        else {\n            window.removeEventListener('mousedown', checkIsContainsTarget);\n        }\n    };\n}\n// update the position of the contour points\n// 更新轮廓点位置\nfunction updateContourPointPosition(downPointPosition, movement, pointElements) {\n    for (const key in pointElements) {\n        setStyle(pointElements[key], 'left', downPointPosition[key][0] + movement.x + 'px');\n        setStyle(pointElements[key], 'top', downPointPosition[key][1] + movement.y + 'px');\n    }\n}\n/* movePoint */\n// updates the coordinates and dimensions of the target element\n// 更新目标元素的坐标和尺寸\nfunction updateTargetStyle(target, { direction, movementX, movementY }, { targetState, coordinate }) {\n    const pointStrategies = memoizeCreateCoordinateStrategies();\n    // the browser calculates and updates the element style information with each frame update to avoid unnecessary calculations\n    // 浏览器在每次帧更新时计算并更新元素样式信息，以避免不必要的计算\n    const styleData = pointStrategies[direction]({\n        left: coordinate.left,\n        top: coordinate.top,\n        width: coordinate.width,\n        height: coordinate.height,\n        offsetX: movementX,\n        offsetY: movementY\n    });\n    whetherUpdateState(direction, targetState, styleData);\n    setStyle(target, styleData);\n    return styleData;\n}\n// updates are required only if hasL or hasT is satisfied\n// 只有满足 hasL 或 hasT 的情况下才需要更新\nfunction whetherUpdateState(direction, targetState, newState) {\n    const { hasL, hasT } = getDirectionDescription(direction);\n    const { left, top, width, height } = getObjectIntValue(newState);\n    if (hasT && hasL) {\n        updateState(targetState, { left, top, width, height });\n    }\n    else if (hasT) {\n        updateState(targetState, { top, width, height });\n    }\n    else if (hasL) {\n        updateState(targetState, { left, width, height });\n    }\n    else {\n        updateState(targetState, { width, height });\n    }\n}\n/**\n * @description drag an outline point to resize it, update coordinate information of outline points synchronously\n * @desc 拖拽某个轮廓点调整大小时，同步更新轮廓点的坐标信息\n * @param target 参考元素\n * @param direction 调整大小时按下的轮廓点\n * @param movementX 按下的轮廓点水平方向移动的距离\n * @param movementY 按下的轮廓点竖直方向移动的距离\n * @param initialTarget 参考元素在调整大小前的尺寸和坐标信息\n * @param pointElements 所有的轮廓点\n * @param pointSize 轮廓点的大小\n * @param pointState 轮廓点的状态\n * @param updateOption { excludeCurPoint: boolean, updateDirection: boolean } 更新的配置项\n * excludeCurPoint: 是否排除当前轮廓点（例如按下左下角轮廓点调整大小时，其他轮廓点的坐标是根据这个轮廓点的移动信息更新的，因此不需要更新这个轮廓点的坐标）\n * updateDirection: 按下某个轮廓点时，pointState对应的状态也会更新，updateDirection控制其是否更新\n */\nfunction updatePointPosition({ direction, movementX, movementY }, { coordinate, pointElements, pointSize, pointState }, updateOption = {}) {\n    const { excludeCurPoint = true, updateDirection = true } = updateOption;\n    const paramStrategies = memoizeCreatePositionStrategies();\n    // obtain the latest coordinate and dimension information of target. Different strategies are used\n    // to calculate coordinates and dimensions at different points\n    // 获取目标元素的最新坐标和尺寸信息。使用不同的策略计算不同点的坐标和尺寸\n    const newCoordinate = paramStrategies[direction]({ ...coordinate, movementX, movementY });\n    // set the position of the contour points based on the new coordinates and dimension information\n    // 根据新的坐标和尺寸信息设置轮廓点的位置\n    const pointPosition = createParentPosition(newCoordinate, pointSize);\n    for (const innerDirection in pointPosition) {\n        // there is no need to update the current drag point\n        // 不需要更新当前拖拽的点\n        if (innerDirection === direction) {\n            const newState = {\n                direction: updateDirection ? direction : null,\n                left: pointPosition[innerDirection][0],\n                top: pointPosition[innerDirection][1],\n                movementX: movementX.value,\n                movementY: movementY.value\n            };\n            updateState(pointState, newState);\n            continue;\n        }\n        // set the innerDirection position of the contour point\n        // 设置轮廓点的innerDirection位置\n        setPosition(pointElements[innerDirection], pointPosition, innerDirection);\n    }\n    if (!excludeCurPoint) {\n        setPosition(pointElements[direction], pointPosition, direction);\n    }\n    return pointPosition;\n}\n// limits the minimum size of the target element\n// 限制目标元素的最小尺寸\nfunction limitTargetResize(target, { direction, movementX, movementY }, { coordinate, containerInfo, minWidth, minHeight, maxWidth, maxHeight }) {\n    // a policy to limit the minimum size when resizing a target\n    // 调整目标大小时限制最小尺寸的策略\n    // TODO 缓存优化\n    const resizeLimitStrategies = createResizeLimitStrategies({ minWidth, minHeight, maxWidth, maxHeight }, { coordinate, containerInfo });\n    resizeLimitStrategies[direction]({ movementX, movementY });\n}\n/* ready to drag and resize - 准备拖动和调整大小 */\n// get coordinates and size information based on dom elements\n// 获取基于dom元素的坐标和大小信息\nfunction getCoordinateByElement(element) {\n    return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        left: element.offsetLeft,\n        top: element.offsetTop\n    };\n}\n// creates/updates objects that record coordinate and dimension information for target elements\n// 创建/更新记录目标元素坐标和维度信息的对象\nfunction updateInitialTarget(targetCoordinate, newCoordinate) {\n    if (targetCoordinate && newCoordinate) {\n        updateState(targetCoordinate, newCoordinate);\n    }\n    return {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        id: generateID()\n    };\n}\nfunction saveDownPointPosition({ downPointPosition, pointElements }) {\n    // the coordinates of all contour points are recorded when the target element is pressed\n    // 当按下目标元素时，记录所有轮廓点的坐标\n    for (const key in pointElements) {\n        downPointPosition[key] = [parseInt(pointElements[key].style.left), parseInt(pointElements[key].style.top)];\n    }\n}\nfunction initTargetStyle(target, size, position) {\n    // ensure element absolute positioning\n    // 确保元素绝对定位\n    setStyle(target, 'position', 'absolute');\n    setStyle(target, numberToStringSize(position));\n    initDescribe().needInitSize && setStyle(target, numberToStringSize(size));\n    function initDescribe() {\n        return {\n            needInitSize: target.offsetWidth === 0 || target.offsetHeight === 0,\n            needInitPosition: getComputedStyle(target).position !== 'absolute'\n        };\n    }\n}\n// Saves the initial data of the target element\n// 保存目标元素的初始化数据\nfunction saveInitialData(target, initialTarget) {\n    // 直接获取相对于父元素的坐标\n    const rect = {\n        left: target.offsetLeft,\n        top: target.offsetTop,\n        width: target.offsetWidth,\n        height: target.offsetHeight\n    };\n    // 处理坐标对象\n    if (initialTarget.isCoordinate) {\n        for (const key of ['left', 'top', 'width', 'height']) {\n            initialTarget[key] = rect[key] || initialTarget[key];\n        }\n    }\n}\nfunction getPointValue(obj, key) {\n    if (!obj.direction)\n        return null;\n    return obj[key];\n}\n// 轮廓点超出body不显示滚动条\nfunction fixContourExceed() {\n    document.body.style.overflow = 'hidden';\n}\n// 为参考线、距离提示添加辅助方法\nfunction mountAssistMethod(element) {\n    element.show = function (coordinate) {\n        if (coordinate) {\n            this.style.width = coordinate.width + 'px';\n            this.style.height = coordinate.height + 'px';\n            this.style.left = coordinate.left + 'px';\n            this.style.top = coordinate.top + 'px';\n        }\n        this.style.display = 'block';\n    };\n    element.showLong = function (coordinate, containerInfo) {\n        if (coordinate.width === 1) {\n            this.style.width = coordinate.width + 'px';\n            this.style.height = containerInfo.height + 'px';\n            this.style.left = coordinate.left + 'px';\n            this.style.top = containerInfo.relBodyOffsetTop + 'px';\n        }\n        else if (coordinate.height === 1) {\n            this.style.width = containerInfo.width + 'px';\n            this.style.height = coordinate.height + 'px';\n            this.style.left = containerInfo.relBodyOffsetLeft + 'px';\n            this.style.top = coordinate.top + 'px';\n        }\n        this.style.display = 'block';\n    };\n    element.hide = function () {\n        this.style.display = 'none';\n    };\n    element.isShow = function () {\n        return this.style.display !== 'none';\n    };\n}\n// 整理参数\nfunction tidyOptions(options) {\n    // pointSize的优先级高于pointStyle.width\n    options.pointSize = options.pointSize || parseInt(options.customStyle.pointStyle.width) || parseInt(options.customStyle.pointStyle.height);\n    return options;\n}\n\nclass RectProcessor {\n    constructor(options) {\n        this.options = options;\n        this._domRects = []; // 描述所有元素的尺寸信息\n        this._showSituation = {}; // 描述辅助线显示情况的信息\n        this._tipDistance = {}; // 描述距离提示的信息\n    }\n    setElement(allEle, dragEle) {\n        this._domRects = allEle.map(ele => this.sizeDescribe(ele));\n        this._selectedRect = this.sizeDescribe(dragEle);\n    }\n    sizeDescribe(element) {\n        const rect = element.getBoundingClientRect();\n        return {\n            width: rect.width,\n            height: rect.height,\n            left: rect.left,\n            top: rect.top,\n            right: rect.right,\n            bottom: rect.bottom,\n            el: element,\n            halfHeight: rect.height / 2,\n            halfWidth: rect.width / 2\n        };\n    }\n    // 除当前拖拽元素外其余元素的 DragDOMRect 信息\n    excludeDragRect(dragEle) {\n        return this._domRects.filter(rect => rect.el !== dragEle);\n    }\n    getNearlyRect(direction, refValue) {\n        const _this = this;\n        const nearlyRect = [];\n        this.excludeDragRect(this.selectedRect.el).forEach(rect => {\n            if (direction === 'top' && topIsNear(rect, refValue)) {\n                nearlyRect.push(rect);\n            }\n            else if (direction === 'left' && leftIsNear(rect, refValue)) {\n                nearlyRect.push(rect);\n            }\n        });\n        return nearlyRect;\n        function topIsNear(rect, refValue) {\n            const nearTop = _this._isNearly(rect.top, refValue);\n            const nearTopCenter = _this._isNearly(rect.bottom, refValue);\n            const nearBottom = _this._isNearly(rect.top + rect.halfHeight, refValue);\n            return nearBottom || nearTopCenter || nearTop;\n        }\n        function leftIsNear(rect, refValue) {\n            const nearLeft = _this._isNearly(rect.left, refValue);\n            const nearRight = _this._isNearly(rect.right, refValue);\n            const nearLeftCenter = _this._isNearly(rect.left + rect.halfWidth, refValue);\n            return nearRight || nearLeftCenter || nearLeft;\n        }\n    }\n    getRefLineCoordinate({ otherRects, dragRect }, { direction, directionValue }) {\n        const pos = {};\n        const { leftList, topList, rightList, bottomList } = wholeDirectionValue(otherRects);\n        if (direction === 'top') {\n            const { max, min } = getMaxAndMin(...leftList, ...rightList, dragRect.left, dragRect.right);\n            pos.width = max - min;\n            pos.height = 1;\n            pos.left = Math.min(...leftList, dragRect.left);\n            pos.top = directionValue;\n        }\n        else {\n            const { max, min } = getMaxAndMin(...topList, ...bottomList, dragRect.top, dragRect.bottom);\n            pos.width = 1;\n            pos.height = max - min;\n            pos.left = directionValue;\n            pos.top = Math.min(...topList, dragRect.top);\n        }\n        return pos;\n        function wholeDirectionValue(rectList) {\n            const leftList = [], topList = [], rightList = [], bottomList = [];\n            rectList.forEach(rect => {\n                leftList.push(rect.left);\n                topList.push(rect.top);\n                rightList.push(rect.right);\n                bottomList.push(rect.bottom);\n            });\n            return {\n                leftList, topList, rightList, bottomList\n            };\n        }\n        function getMaxAndMin(...rest) {\n            const min = Math.min(...rest);\n            const max = Math.max(...rest);\n            return {\n                min,\n                max\n            };\n        }\n    }\n    // 添加需要显示参考线对应的条件信息和显示方向\n    appendCondition(condition, adsorbKey, anotherRect) {\n        if (!this._showSituation[adsorbKey])\n            this._showSituation[adsorbKey] = new Set();\n        const self = this;\n        const state = recomposeCondition(condition, adsorbKey, anotherRect);\n        this._showSituation[adsorbKey].add(state);\n        function recomposeCondition(condition, adsorbKey, anotherRect) {\n            const state = {};\n            state.lineValue = condition.lineValue;\n            state.anotherRect = anotherRect;\n            state.lineNode = condition.lineNode;\n            state.nearlyRect = self.getNearlyRect(adsorbKey, condition.lineValue);\n            state.isCenter = condition.isCenter;\n            state.distance = condition.distance;\n            state.position = self.getRefLineCoordinate({ otherRects: state.nearlyRect, dragRect: self.selectedRect }, { direction: adsorbKey, directionValue: condition.lineValue });\n            return state;\n        }\n    }\n    calculateDistance(adsorbKey, dragRect, anotherRect, newCondition) {\n        const distance = { value: 0, position: { left: 0, top: 0 } };\n        const tipWidth = parseInt(this.options.customStyle.tipStyle.width);\n        const tipHeight = parseInt(this.options.customStyle.tipStyle.height);\n        // MARK 1.元素未相交 2.元素相交\n        // MARK 吸附后distance = 0\n        // // Y轴方向对齐, 计算X轴方向距离\n        if (adsorbKey === 'left')\n            calculateYDistance();\n        // X轴方向对齐, 计算Y轴方向距离\n        if (adsorbKey === 'top')\n            calculateXDistance();\n        function calculateYDistance() {\n            // 未相交 - dragRect 在上面\n            if (dragRect.bottom < anotherRect.top) {\n                distance.value = anotherRect.top - dragRect.bottom;\n                distance.position.top = dragRect.bottom + distance.value / 2 - tipHeight / 2;\n                distance.position.left = newCondition.lineValue - tipWidth / 2;\n            }\n            // 未相交 - dragRect 在下面\n            if (dragRect.top > anotherRect.bottom) {\n                distance.value = dragRect.top - anotherRect.bottom;\n                distance.position.top = anotherRect.bottom + distance.value / 2 - tipHeight / 2;\n                distance.position.left = newCondition.lineValue - tipWidth / 2;\n            }\n        }\n        function calculateXDistance() {\n            // 未相交 - dragRect 在左边\n            if (dragRect.right < anotherRect.left) {\n                distance.value = anotherRect.left - dragRect.right;\n                distance.position.left = dragRect.right + distance.value / 2 - tipWidth / 2;\n                distance.position.top = newCondition.lineValue - tipHeight / 2;\n            }\n            // 未相交 - dragRect 在右边\n            if (dragRect.left > anotherRect.right) {\n                distance.value = dragRect.left - anotherRect.right;\n                distance.position.left = anotherRect.right + distance.value / 2 - tipWidth / 2;\n                distance.position.top = newCondition.lineValue - tipHeight / 2;\n            }\n        }\n        this._tipDistance[revertKey(adsorbKey)] = distance;\n        function revertKey(adsorbKey) {\n            return adsorbKey === 'left' ? 'Y' : 'X';\n        }\n    }\n    // 检查两个元素是否相交\n    isIntersect(adsorbKey, dragRect, anotherRect) {\n        const intersectSituation = {};\n        if (adsorbKey === 'left') {\n            if (isBelow())\n                intersectSituation.dragRectIsBelow = true;\n            if (onTop())\n                intersectSituation.dragRectOnTop = true;\n            if (dragIncluded())\n                intersectSituation.dragRectIsIncluded = true;\n            if (anotherIncluded())\n                intersectSituation.anotherRectIsIncluded = true;\n        }\n        function isBelow() {\n            return dragRect.top > anotherRect.top && dragRect.top < anotherRect.bottom;\n        }\n        function onTop() {\n            return dragRect.top < anotherRect.top && dragRect.bottom > anotherRect.top;\n        }\n        function dragIncluded() {\n            return dragRect.top > anotherRect.top && dragRect.bottom < anotherRect.bottom;\n        }\n        function anotherIncluded() {\n            return dragRect.top < anotherRect.top && dragRect.bottom > anotherRect.bottom;\n        }\n        return intersectSituation;\n    }\n    resetSituation() {\n        this._showSituation = {};\n    }\n    resetTipDistance() {\n        this._tipDistance = {};\n    }\n    isContains(container, elements) {\n        const containerRect = container.getBoundingClientRect();\n        const rectList = elements.map(el => el.getBoundingClientRect());\n        const containList = [];\n        rectList.forEach(rect => {\n            if (singleContain(containerRect, rect))\n                containList.push(rect);\n        });\n        function singleContain(containerRect, rect) {\n            return containerRect.left < rect.left\n                && containerRect.right > rect.right\n                && containerRect.top < rect.top\n                && containerRect.bottom > rect.bottom;\n        }\n        return containList;\n    }\n    // 选中元素的DragDomRect信息\n    get selectedRect() {\n        return { ...this._selectedRect };\n    }\n    get rectList() {\n        return this._domRects.slice();\n    }\n    get showSituation() {\n        return { ...this._showSituation };\n    }\n    get compareConditions() {\n        return { ...this._compareConditions };\n    }\n    get tipDistance() {\n        return { ...this._tipDistance };\n    }\n    buildCompareConditions(anotherRect, lines) {\n        const { halfWidth: dragWidthHalf, halfHeight: dragHeightHalf } = this.selectedRect;\n        const { top, height, bottom, left, width, right, halfHeight: itemHeightHalf, halfWidth: itemWidthHalf } = anotherRect;\n        /*\n        * eg：this._isNearly(this.selectedRect.bottom, top)\n        * 如果被拖拽元素的底边与参考元素的顶边达到吸附条件时\n        * 那么标线需要显示的位置就是，lineValue： 参考元素的顶部top\n        * 被拖拽元素需要显示的位置就是 dragValue：参考元素的top - 拖拽元素的高度\n        * 画图看更直观一些\n        *\n        * MARK 是否可以通过一个策略对象来计算出对比情况\n        * */\n        this._compareConditions = {\n            // 对比top - 检查X轴\n            top: [\n                // xt-top 被拖拽元素的顶边与参考元素的顶边达到吸附条件\n                {\n                    isNearly: this._isNearly(this.selectedRect.top, top), // 是否达到吸附条件\n                    lineNode: lines.xt, // 对应的真实DOM\n                    lineValue: top, // x轴上面那条线的的top（相对视口顶部的距离）\n                    dragValue: top,\n                    distance: this.selectedRect.top - top,\n                    equality: height === this.selectedRect.height\n                },\n                // xt-bottom 被拖拽元素的底边与参考元素的顶边达到吸附条件\n                {\n                    isNearly: this._isNearly(this.selectedRect.bottom, top),\n                    lineNode: lines.xt,\n                    lineValue: top, // x轴上面那条线的的top\n                    dragValue: top - this.selectedRect.height,\n                    distance: this.selectedRect.bottom - top,\n                    equality: height === this.selectedRect.height\n                },\n                // xc 被拖拽元素的x轴中心与参考元素的x轴中心达到吸附条件\n                {\n                    isNearly: this._isNearly(this.selectedRect.top + dragHeightHalf, top + itemHeightHalf),\n                    lineNode: lines.xc,\n                    lineValue: top + itemHeightHalf,\n                    dragValue: top + itemHeightHalf - dragHeightHalf, // 如果这个值 <= gap，说明达到吸附条件\n                    distance: this.selectedRect.top + dragHeightHalf - (top + itemHeightHalf),\n                    equality: height === this.selectedRect.height,\n                    isCenter: true\n                },\n                // xb-bottom 被拖拽元素的底边与参考元素的底边达到吸附条件\n                {\n                    isNearly: this._isNearly(this.selectedRect.bottom, bottom),\n                    lineNode: lines.xb,\n                    lineValue: bottom,\n                    dragValue: bottom - this.selectedRect.height,\n                    distance: this.selectedRect.bottom - bottom,\n                    equality: height === this.selectedRect.height\n                },\n                // xb-top 被拖拽元素的顶边与参考元素的底边达到吸附条件\n                {\n                    isNearly: this._isNearly(this.selectedRect.top, bottom),\n                    lineNode: lines.xb,\n                    lineValue: bottom,\n                    dragValue: bottom,\n                    distance: this.selectedRect.top - bottom,\n                    equality: height === this.selectedRect.height\n                }\n            ],\n            // 对比left - 检查Y轴\n            left: [\n                // yl-left\n                {\n                    isNearly: this._isNearly(this.selectedRect.left, left),\n                    lineNode: lines.yl,\n                    lineValue: left,\n                    dragValue: left,\n                    distance: this.selectedRect.left - left,\n                    equality: width === this.selectedRect.width\n                },\n                // yl-right\n                {\n                    isNearly: this._isNearly(this.selectedRect.right, left),\n                    lineNode: lines.yl,\n                    lineValue: left,\n                    dragValue: left - this.selectedRect.width,\n                    distance: this.selectedRect.right - left,\n                    equality: width === this.selectedRect.width\n                },\n                // yc\n                {\n                    isNearly: this._isNearly(this.selectedRect.left + dragWidthHalf, left + itemWidthHalf),\n                    lineNode: lines.yc,\n                    lineValue: left + itemWidthHalf,\n                    dragValue: left + itemWidthHalf - dragWidthHalf,\n                    distance: this.selectedRect.left + dragWidthHalf - (left + itemWidthHalf),\n                    equality: width === this.selectedRect.width,\n                    isCenter: true\n                },\n                // yr-left\n                {\n                    isNearly: this._isNearly(this.selectedRect.right, right),\n                    lineNode: lines.yr,\n                    lineValue: right,\n                    dragValue: right - this.selectedRect.width,\n                    distance: this.selectedRect.right - right,\n                    equality: width === this.selectedRect.width\n                },\n                // yr-right\n                {\n                    isNearly: this._isNearly(this.selectedRect.left, right),\n                    lineNode: lines.yr,\n                    lineValue: right,\n                    dragValue: right,\n                    distance: this.selectedRect.left - right,\n                    equality: width === this.selectedRect.width\n                }\n            ]\n        };\n    }\n    _isNearly(dragValue, targetValue, isStrict = false) {\n        return isStrict\n            ? dragValue === targetValue\n            : Math.abs(dragValue - targetValue) <= this.options.gap;\n    }\n}\n\nconst REF_LINE_CLASS_NAME = 'ref-line';\nconst DISTANCE_TIP_CLASS_NAME = 'distance-tip';\nclass RefLine {\n    constructor(options, stateManager) {\n        this.options = options;\n        this.stateManager = stateManager;\n        this.lines = { xt: null, xc: null, xb: null, yl: null, yc: null, yr: null };\n        this.tipEls = { X: null, Y: null };\n        this.isHasAdsorbElementY = false;\n        this.isHasAdsorbElementX = false;\n        this.isCenterX = false;\n        this.isCenterY = false;\n        this.name = 'refLine';\n    }\n    init() {\n        this.createLines();\n        this.createTipEl();\n        this.rectManager = new RectProcessor(this.options);\n    }\n    unbind() {\n        removeElements(this.lines);\n        removeElements(this.tipEls);\n    }\n    drag(dragEls, { movement, _updateContourPointPosition, _updateState, syncOtherEl }) {\n        const adsorbCallback = ({ top, left }) => {\n            movement.x -= left;\n            movement.y -= top;\n            _updateContourPointPosition(movement);\n            _updateState(movement);\n            syncOtherEl(movement);\n        };\n        this.startCheck(dragEls, 'drag', adsorbCallback, movement);\n    }\n    dragStart({ composeCoordinate, publicContainer }) {\n        // 如果被选中的元素数量小于等于1，则不需要创建多选的盒子\n        if (!this.stateManager.isRegionSelection)\n            return;\n        const _this = this;\n        // 创建多选的包裹元素\n        createSelectionBox();\n        // 保存包裹元素的位置信息\n        saveBoxStartPos();\n        function createSelectionBox() {\n            const el = document.createElement('div');\n            setStyle(el, {\n                ...numberToStringSize(composeCoordinate),\n                position: 'absolute'\n            });\n            _this.refElement = el;\n            publicContainer.appendChild(el);\n        }\n        function saveBoxStartPos() {\n            _this.refElementPosition = {\n                left: parseInt(_this.refElement.style.left),\n                top: parseInt(_this.refElement.style.top)\n            };\n        }\n    }\n    dragEnd({ publicContainer }) {\n        if (!this.stateManager.isRegionSelection)\n            return;\n        this.refElement?.remove();\n        this.refElement = null;\n    }\n    resize({ allTarget, privateTarget }, { movementX, movementY, _updateTargetStyle, _updatePointPosition }) {\n        const adsorbCallback = ({ top, left }) => {\n            movementX.value -= left;\n            movementY.value -= top;\n            _updateTargetStyle({ movementX: movementX.value, movementY: movementY.value });\n            _updatePointPosition({ movementX: movementX.value, movementY: movementY.value });\n        };\n        this.startCheck({ allTarget, privateTarget }, 'resize', adsorbCallback);\n    }\n    targetPressChange(isPress, dragEls) {\n        isPress\n            ? this.startCheck(dragEls, 'drag')\n            : this.checkEnd();\n    }\n    pointPressChange(isPress, dragEls) {\n        isPress\n            ? this.startCheck(dragEls, 'drag')\n            : this.checkEnd();\n    }\n    createLines() {\n        for (const key in this.lines) {\n            const node = this.lines[key] = document.createElement('div');\n            node.classList.add(REF_LINE_CLASS_NAME);\n            node.classList.add(key);\n            setStyle(node, this.options.customStyle.refLineStyle);\n            // 挂载一些辅助方法\n            mountAssistMethod(node);\n            document.body.appendChild(node);\n        }\n    }\n    createTipEl() {\n        for (const elKey in this.tipEls) {\n            const el = document.createElement('div');\n            el.classList.add(DISTANCE_TIP_CLASS_NAME);\n            setStyle(el, this.options.customStyle.tipStyle);\n            mountAssistMethod(el);\n            document.body.appendChild(el);\n            this.tipEls[elKey] = el;\n        }\n    }\n    // 检查是否有达到吸附条件的元素\n    startCheck(dragEls, way, adsorbCallback, movement) {\n        const _this = this;\n        // 如果是多选需要主动更新包裹盒子的位置\n        updateSelectionBoxPos();\n        // 记录参与本次操作的所有元素\n        this.rectManager.setElement(allElements(), dragElement());\n        // 获取要与dragRect对比的rect对象\n        const checkDragRect = this.rectManager.excludeDragRect(dragElement());\n        // 开始新一轮的check需要重置上一次check的数据\n        this.checkEnd();\n        // 创建参考线的描述数据\n        createRefLineDescribeData();\n        // 显示参考线\n        this.options.showRefLine && this.executeShowRefLine();\n        // 执行吸附操作\n        this.options.adsorb && this.executeAdsorb({ way, adsorbCallback });\n        // 显示距离提示\n        this.options.showDistance && showDistanceTip();\n        function showDistanceTip() {\n            // 计算距离信息\n            _this.calculateDistance();\n            // 显示距离\n            _this.executeShowDistanceTip();\n        }\n        function createRefLineDescribeData() {\n            // 遍历nodeList\n            Array.from(checkDragRect).forEach((item) => {\n                if (item.el === dragElement())\n                    return;\n                // 构建 dragRect 与其他rect对象的关系（是否达成吸附条件）\n                _this.buildConditions(item);\n                // 通过上一步构建的conditions进行检查并记录\n                _this.executeCheckByConditions({\n                    way,\n                    anotherRect: item,\n                    dragRect: _this.rectManager.selectedRect,\n                    conditions: _this.rectManager.compareConditions\n                });\n            });\n        }\n        // 拖拽的元素,多选的情况下是包裹的元素(未显示)\n        function dragElement() {\n            return _this.refElement ? _this.refElement : dragEls.privateTarget;\n        }\n        // 参与对比的所有元素\n        function allElements() {\n            // 多选的时候还需要排除当前被选中的元素\n            const notSelectedEls = dragEls.allTarget.filter(item => !_this.stateManager.regionSelectedElement.includes(item));\n            // 非多选的情况下allElements中包含当前拖拽的元素，多选的情况下与其保持一致\n            return _this.refElement ? [...notSelectedEls, _this.refElement] : notSelectedEls;\n        }\n        function updateSelectionBoxPos() {\n            if (_this.refElement) {\n                _this.refElement.style.top = _this.refElementPosition.top + movement?.y + 'px';\n                _this.refElement.style.left = _this.refElementPosition.left + movement?.x + 'px';\n            }\n        }\n    }\n    calculateDistance() {\n        for (const adsorbKey in this.rectManager.showSituation) {\n            const dragState = priorityCenterState(this.rectManager.showSituation[adsorbKey]);\n            const dragRect = this.rectManager.sizeDescribe(this.rectManager.selectedRect.el);\n            this.rectManager.calculateDistance(adsorbKey, dragRect, dragState.anotherRect, dragState);\n        }\n        // 优先获取中间的参考线对应的condition信息\n        function priorityCenterState(arrayLike) {\n            return [...arrayLike].find(item => item.isCenter) || [...arrayLike][0];\n        }\n    }\n    // 显示距离提示\n    executeShowDistanceTip() {\n        for (const tipKey in this.rectManager.tipDistance) {\n            needShow(this.rectManager.tipDistance[tipKey].value, this.options.gap)\n                && this.tipEls[tipKey].show(this.rectManager.tipDistance[tipKey].position);\n            needShow(this.rectManager.tipDistance[tipKey].value, this.options.gap)\n                && (this.tipEls[tipKey].innerText = this.rectManager.tipDistance[tipKey].value);\n        }\n        function needShow(distance, gap) {\n            return distance > gap;\n        }\n    }\n    // 构建对比情况\n    buildConditions(item) {\n        this.rectManager.buildCompareConditions(item, this.lines);\n    }\n    executeCheckByConditions({ conditions, way, dragRect, anotherRect }) {\n        for (let adsorbKey in conditions) {\n            conditions[adsorbKey].forEach((condition) => {\n                if (!condition.isNearly)\n                    return;\n                if (way === 'drag') {\n                    // 显示达到吸附条件的线，如果一个方向已经有一条线满足吸附条件了，那么必须宽高相等才能显示其他线\n                    if ((!this.isHasAdsorbElementY && adsorbKey === 'left') || (!this.isHasAdsorbElementX && adsorbKey === 'top')) {\n                        this.rectManager.appendCondition(condition, adsorbKey, anotherRect);\n                    }\n                    else {\n                        this.rectManager.appendCondition(condition, adsorbKey, anotherRect);\n                    }\n                }\n                else if (way === 'resize') {\n                    // 如果不是中间的线直接显示\n                    !condition.isCenter && this.rectManager.appendCondition(condition, adsorbKey, anotherRect);\n                    // MARK 某一个轴，如果是中间的线达到吸附条件，其他两条线必须也达到吸附条件才显示\n                    if (condition.isCenter && adsorbKey === 'top' && this.rectManager._isNearly(anotherRect.height, dragRect.height)) {\n                        this.rectManager.appendCondition(condition, adsorbKey, anotherRect);\n                    }\n                    else if (condition.isCenter && adsorbKey === 'left' && this.rectManager._isNearly(anotherRect.width, dragRect.width)) {\n                        this.rectManager.appendCondition(condition, adsorbKey, anotherRect);\n                    }\n                }\n                if (adsorbKey === 'top') {\n                    this.isHasAdsorbElementX = true;\n                    this.isCenterX = this.isCenterX || condition.isCenter;\n                }\n                else {\n                    this.isHasAdsorbElementY = true;\n                    this.isCenterY = this.isCenterY || condition.isCenter;\n                }\n            });\n        }\n    }\n    /**\n     * 显示参考线操作\n     * @param type { 'short' | 'long' }\n     * short 显示两个元素之间的最短参考线\n     * long 显示铺满整个容器的参考线\n     */\n    executeShowRefLine(type = 'long') {\n        const methodName = type === 'short' ? 'show' : 'showLong';\n        for (const adsorbKey in this.rectManager.showSituation) {\n            [...this.rectManager.showSituation[adsorbKey]]\n                .forEach(item => item.lineNode[methodName](item.position, this.stateManager.currentState.containerInfo));\n        }\n    }\n    // 吸附操作\n    executeAdsorb({ way, adsorbCallback }) {\n        let topList = Array.from(this.rectManager.showSituation.top || []), leftList = Array.from(this.rectManager.showSituation.left || []);\n        if (way === 'resize') {\n            // MARK X轴有满足吸附条件的元素 而且 X轴的是中间的线则过滤掉中间的线（即resize时中间的线不吸附）\n            (this.isHasAdsorbElementY && this.isCenterY) && (leftList = leftList.filter((item) => !item.isCenter));\n            (this.isHasAdsorbElementX && this.isCenterX) && (topList = topList.filter((item) => !item.isCenter));\n        }\n        if (this.isHasAdsorbElementY || this.isHasAdsorbElementX)\n            adsorbCallback?.({\n                top: nearestInstance(topList, this.options.gap) || 0,\n                left: nearestInstance(leftList, this.options.gap) || 0\n            });\n        function nearestInstance(list, gap) {\n            return list\n                .map(m => Math.abs(m.distance) <= gap ? m.distance : 0)\n                .find(item => Math.abs(item) > 0);\n        }\n    }\n    checkEnd() {\n        this.hideRefLine();\n        this.hideTip();\n        this.rectManager.resetSituation();\n        this.rectManager.resetTipDistance();\n    }\n    hideRefLine() {\n        this.isHasAdsorbElementX = false;\n        this.isHasAdsorbElementY = false;\n        this.isCenterX = false;\n        this.isCenterY = false;\n        // 隐藏所有标线\n        Object.values(this.lines).forEach((item) => item.hide());\n    }\n    hideTip() {\n        for (const elKey in this.tipEls) {\n            this.tipEls[elKey].hide();\n        }\n    }\n}\n\nconst shiftIsPress = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\nconst altIsPress = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\nconst ctrlIsPress$1 = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\nconst defaultShortcut = {\n    'ctrl + a': event => {\n        event.preventDefault();\n        console.log('全选');\n    },\n    'ctrl + c': event => {\n        event.preventDefault();\n        console.log('复制');\n    },\n    'ctrl + v': event => {\n        event.preventDefault();\n        console.log('粘贴');\n    },\n    'ctrl + h': event => {\n        event.preventDefault();\n        console.log('帮助');\n    },\n    'ctrl + z': event => {\n        event.preventDefault();\n        console.log('撤销');\n    },\n    'ctrl + y': event => {\n        event.preventDefault();\n        console.log('重做');\n    }\n};\nclass Shortcut {\n    constructor() {\n        this.enableMap = {};\n        this.shortcuts = {};\n        this.name = 'shortcut';\n        this.bindTriggerShortcut = this.triggerShortcut.bind(this);\n        this.configureShortcuts(defaultShortcut);\n    }\n    init() {\n        window.addEventListener('keydown', this.bindTriggerShortcut);\n        window.addEventListener('keyup', this.getDescribeFromEvent);\n    }\n    unbind() {\n        window.removeEventListener('keydown', this.bindTriggerShortcut);\n        window.removeEventListener('keyup', this.getDescribeFromEvent);\n    }\n    // 注册快捷键\n    registerShortcut(shortcut, action, options) {\n        shortcut = shortcut.replaceAll(' ', '').toUpperCase();\n        shortcut = this.functionOrder(shortcut);\n        this.enableMap[shortcut] = this.enableMap[shortcut] ?? true;\n        const { priority = 0 } = options || {};\n        if (!this.shortcuts[shortcut]) {\n            this.shortcuts[shortcut] = [];\n        }\n        this.shortcuts[shortcut].push({ action, priority });\n        // 优先级高的先执行\n        this.shortcuts[shortcut].sort((pre, next) => next.priority - pre.priority);\n    }\n    // 功能键排序\n    functionOrder(shortcut) {\n        if (shortcut.trim().indexOf('++') > -1) {\n            throw Error('+ 不可以做为快捷键操作的key，如有必要请自行实现');\n        }\n        const keyList = [];\n        shortcut.indexOf(Shortcut.CTRL) > -1 && keyList.push(Shortcut.CTRL);\n        shortcut = shortcut.replace(Shortcut.CTRL, '');\n        shortcut.indexOf(Shortcut.SHIFT) > -1 && keyList.push(Shortcut.SHIFT);\n        shortcut = shortcut.replace(Shortcut.SHIFT, '');\n        shortcut.indexOf(Shortcut.ALT) > -1 && keyList.push(Shortcut.ALT);\n        shortcut = shortcut.replace(Shortcut.ALT, '');\n        shortcut = shortcut.replaceAll('+', '');\n        keyList.push(shortcut);\n        return keyList.join('+');\n    }\n    // 触发快捷键\n    triggerShortcut(event) {\n        const shortcut = this.getDescribeFromEvent(event);\n        if (this.shortcuts[shortcut]) {\n            this.shortcuts[shortcut].forEach(item => item.action(event));\n        }\n    }\n    // 获取键盘事件的快捷键描述\n    getDescribeFromEvent(event) {\n        listenSpecialKey();\n        const describe = [];\n        if (event.ctrlKey)\n            describe.push(Shortcut.CTRL);\n        if (event.shiftKey)\n            describe.push(Shortcut.SHIFT);\n        if (event.altKey)\n            describe.push(Shortcut.ALT);\n        describe.push(event.key.toUpperCase());\n        return describe.join('+');\n        function listenSpecialKey() {\n            if (event.key === 'Control')\n                ctrlIsPress$1.value = event.type === 'keydown';\n            if (event.key === 'Shift')\n                shiftIsPress.value = event.type === 'keydown';\n            if (event.key === 'Alt')\n                altIsPress.value = event.type === 'keydown';\n        }\n    }\n    // 配置默认快捷键\n    configureShortcuts(shortcuts) {\n        for (const shortcutsKey in shortcuts) {\n            this.registerShortcut(shortcutsKey, shortcuts[shortcutsKey]);\n        }\n    }\n    // 启用快捷键\n    enableShortcut(shortcut) { }\n    // 禁用快捷键\n    disableShortcut(shortcut) { }\n}\nShortcut.CTRL = 'CTRL';\nShortcut.SHIFT = 'SHIFT';\nShortcut.ALT = 'ALT';\nfunction useSpecialKey() {\n    return { ctrlIsPress: ctrlIsPress$1, shiftIsPress, altIsPress };\n}\n\nconst { ctrlIsPress } = useSpecialKey();\n/*\n* 获取容器元素可以在按下鼠标的时候获取，这个时候DOM必然已经插入完毕\n* */\nclass RegionalSelection {\n    constructor(containerSelector, stateManager) {\n        this.containerSelector = containerSelector;\n        this.stateManager = stateManager;\n        this.regionalEl = null;\n        this.startCoordinate = { x: 0, y: 0 };\n        this.isPress = false;\n        this.name = 'regionalSelection';\n        this.bindMouseDown = this._mousedown.bind(this);\n        this.bindMouseMove = this._mouseMove.bind(this);\n        this.bindMouseUp = this._mouseup.bind(this);\n        this.bindClickSelection = this._clickSelection.bind(this);\n    }\n    init() {\n        window.addEventListener('mousedown', this.bindMouseDown);\n        window.addEventListener('mousemove', this.bindMouseMove);\n        window.addEventListener('mouseup', this.bindMouseUp);\n    }\n    unbind() {\n        window.removeEventListener('mousedown', this.bindMouseDown);\n        window.removeEventListener('mousemove', this.bindMouseMove);\n        window.removeEventListener('mouseup', this.bindMouseUp);\n        this.containerEl?.removeEventListener('click', this.bindClickSelection);\n        this.containerSelector = null;\n        this.containerEl = null;\n    }\n    dragStart({ privateTarget, resetRegionalSelectionData }) {\n        // 如果按下ctrl键则不需要检查是否选中\n        if (ctrlIsPress.value)\n            return;\n        // 如果按下的是未选中的元素，重置已选中的元素\n        if (!isSelectedEl(this)) {\n            this.resetStateAndStyle();\n            resetRegionalSelectionData();\n        }\n        function isSelectedEl(context) {\n            return context.stateManager.getStateByEle(privateTarget).regionSelected;\n        }\n    }\n    getContainer() {\n        if (this.containerEl)\n            return this.containerEl;\n        this.containerEl = getElement(this.containerSelector);\n        // 添加点击多选\n        this.containerEl.addEventListener('click', this.bindClickSelection);\n        return this.containerEl;\n    }\n    _mousedown(event) {\n        // 保证已经获取到了容器元素\n        this.getContainer();\n        if (event.target !== this.containerEl)\n            return;\n        this.isPress = true;\n        // 确保已经创建了选择框\n        if (!this.regionalEl) {\n            this.regionalEl = document.createElement('div');\n            this.regionalEl.classList.add('regional-selection');\n            document.body.appendChild(this.regionalEl);\n        }\n        // 计算并设置元素样式\n        this.startCoordinate.x = event.pageX;\n        this.startCoordinate.y = event.pageY;\n        setStyle(this.regionalEl, this.stateManager.currentState.options.customStyle.regionStyle);\n        // 重置选中元素的状态和样式\n        this.resetStateAndStyle();\n    }\n    _mouseup() {\n        if (!this.isPress)\n            return;\n        this.isPress = false;\n        this.regionalEl.style.display = 'none';\n    }\n    _mouseMove(event) {\n        if (!this.isPress)\n            return;\n        const _this = this;\n        // 先重置所有元素的选中标识和样式\n        this.resetStateAndStyle();\n        // 为选中的元素添加选中样式\n        updateRegionStyle();\n        // 被选中的元素列表\n        const selectedEls = this.containList(this.stateManager.allElement).map(m => m.el);\n        // 更新选中元素的状态和样式\n        changeSelected();\n        function updateRegionStyle() {\n            const offsetX = event.pageX - _this.startCoordinate.x;\n            const offsetY = event.pageY - _this.startCoordinate.y;\n            const regionalStyle = {\n                width: Math.abs(offsetX),\n                height: Math.abs(offsetY),\n                left: offsetX < 0 ? _this.startCoordinate.x + offsetX : _this.startCoordinate.x,\n                top: offsetY < 0 ? _this.startCoordinate.y + offsetY : _this.startCoordinate.y\n            };\n            setStyle(_this.regionalEl, 'display', 'block');\n            setStyle(_this.regionalEl, numberToStringSize(regionalStyle));\n        }\n        function changeSelected(elementList) {\n            selectedEls.forEach(el => _this.setSelected(el, true));\n        }\n    }\n    _clickSelection(e) {\n        // 没有按下ctrl\n        if (!ctrlIsPress.value)\n            return;\n        // 点击的不是拖拽元素\n        if (e.target === this.containerEl)\n            return;\n        // 如果点击的元素是某个拖拽元素\n        if (this.stateManager.allElement.includes(e.target)) {\n            const regionalSelected = this.stateManager.getStateByEle(e.target).regionSelected;\n            // 将它设置 选中/非选中 状态\n            this.setSelected(e.target, !regionalSelected);\n        }\n    }\n    resetStateAndStyle() {\n        this.stateManager.allElement.forEach(el => this.setSelected(el, false));\n    }\n    setSelected(el, isSelected) {\n        const selectedStyle = this.stateManager.getStateByEle(el).options.customStyle.selectedStyle;\n        setStyle(el, isSelected ? selectedStyle : resetObject(selectedStyle, 'none'));\n        this.stateManager.setStateByEle(el, 'regionSelected', isSelected);\n    }\n    containList(elList) {\n        const regionalRect = this.regionalEl.getBoundingClientRect();\n        return elList.map(m => Object.assign(m.getBoundingClientRect(), { el: m }))\n            .filter(rect => this._isContains(rect, regionalRect));\n    }\n    _isContains(rect, referRect) {\n        return rect.left >= referRect.left\n            && rect.top >= referRect.top\n            && rect.right <= referRect.right\n            && rect.bottom <= referRect.bottom;\n    }\n}\n\nconst pluginManager = new PluginManager();\nfunction usePlugin(options) {\n    options.skill.regionalSelection && enableRegionalSelection(options.containerSelector, stateManager);\n    options.skill.refLine && enableRefLine(tidyRefLineOptions(options), stateManager);\n    options.skill.shortcut && enableShortcut();\n    pluginManager.installPlugin();\n}\nfunction tidyRefLineOptions(options) {\n    const result = {};\n    result.customStyle = options.customStyle;\n    result.gap = options.gap;\n    result.adsorb = options.adsorb;\n    result.showRefLine = options.showRefLine;\n    result.showDistance = options.showDistance;\n    return result;\n}\nfunction enableRefLine(options, stateManager) {\n    const refLine = new RefLine(options, stateManager);\n    pluginManager.registerPlugin(refLine.name, refLine);\n}\nfunction enableShortcut() {\n    const shortcut = new Shortcut();\n    pluginManager.registerPlugin(shortcut.name, shortcut);\n}\nfunction enableRegionalSelection(container, stateManager) {\n    const regionalSelection = new RegionalSelection(container, stateManager);\n    pluginManager.registerPlugin(regionalSelection.name, regionalSelection);\n}\n\nconst _defaultOptions = {\n    containerSelector: 'body',\n    minWidth: 10, // minimum width - 最小宽度\n    minHeight: 10, // minimum height - 最小高度\n    maxWidth: 999999, // 最大宽度\n    maxHeight: 999999, // 最大高度\n    gap: 3, // 吸附的最小间距\n    showRefLine: true, // 显示参考线\n    adsorb: true, // 开启吸附功能\n    showDistance: true, // 显示组件间距\n    // pageHasScrollBar: false, // whether the page has a scroll bar - 页面是否有滚动条\n    // ratio: [3, 4],\n    grid: true,\n    initialInfo: {\n        width: 200,\n        height: 200,\n        left: 0,\n        top: 0\n    },\n    skill: {\n        resize: true, // whether the size adjustment is supported - 是否支持大小调整\n        drag: true, // whether to support dragging - 是否支持拖动\n        refLine: true, // whether to support refLine - 是否支持参考线\n        shortcut: true, // whether to support shortcut - 是否支持快捷键\n        regionalSelection: true, // whether multiple region selection is supported - 是否支持区域多选\n        limitDragDirection: null // restricted direction of movement - 限制移动方向\n    },\n    customClass: {\n        customPointClass: ClassName.OutlinePoint, // 自定义轮廓点的类名\n    },\n    callbacks: {},\n    customStyle: {\n        pointStyle: {\n            position: 'absolute',\n            display: 'none',\n            boxSizing: 'border-box',\n            width: '10px',\n            height: '10px',\n            zIndex: '88888',\n            border: '1px solid #999',\n            borderRadius: '50%'\n        },\n        tipStyle: {\n            position: 'absolute',\n            display: 'none',\n            boxSizing: 'border-box',\n            width: '34px',\n            height: '18px',\n            zIndex: '99999',\n            padding: '2px 5px',\n            fontSize: '12px',\n            background: '#0086FF',\n            borderRadius: '7px',\n            color: '#fff',\n            textAlign: 'center',\n            lineHeight: '14px'\n        },\n        refLineStyle: {\n            position: 'absolute',\n            display: 'none',\n            opacity: '0.7',\n            background: '#4DAEFF',\n            zIndex: '88888'\n        },\n        selectedStyle: {\n            outline: '1px solid black'\n        },\n        regionStyle: {\n            position: 'absolute',\n            border: '1px solid aqua',\n            zIndex: '88888',\n            backgroundColor: 'rgba(0, 255, 255, 0.1)'\n        }\n    }\n};\nfunction defaultOptions() {\n    return _defaultOptions;\n}\nconst todoUnmountCbs = [];\nfunction addGlobalUnmountCb(cb) {\n    todoUnmountCbs.push(cb);\n}\nfunction unMountGlobalCb() {\n    todoUnmountCbs.forEach(cb => cb());\n    todoUnmountCbs.length = 0;\n}\n\n// check that the type of options passed in is correct\n// 检查传入的选项类型是否正确\nfunction checkParameterType(defaultOptions, options = {}) {\n    for (const key in defaultOptions) {\n        const value = options[key];\n        if (isNullOrUndefined(value))\n            continue;\n        const originType = Array.isArray(defaultOptions[key]) ? 'array' : typeof defaultOptions[key];\n        const paramsType = Array.isArray(value) ? 'array' : typeof value;\n        baseErrorTips(originType !== paramsType, `The type of options.${key} should be ${originType}, But the ${paramsType} type is passed in.`);\n    }\n}\n// Check that the options passed in are valid\n// 检查传入的选项是否合法\nfunction checkParameterValue(options) {\n    checkOptionPosition(options?.initialInfo);\n    checkOptionSize(options);\n    checkCustomStyle(options?.customStyle);\n}\nfunction checkOptionSize(options = {}) {\n    baseWarnTips(errorSize(), 'The maximum value cannot be less than the minimum value, and the maximum and minimum values have been replaced with each other.');\n    // 最大最小值无效时替换最大最小值\n    fixMaxAndMin();\n    baseWarnTips(lessThanMinimumH() && lessThanMinimumW(), 'The initial size cannot be less than the minimum size.');\n    baseWarnTips(greaterThanMaximumH() && greaterThanMaximumW(), 'The initial size cannot be greater than the maximum size.');\n    function lessThanMinimumH() {\n        return options?.initialInfo?.height && options.minHeight && (options.initialInfo.height < options.minHeight);\n    }\n    function lessThanMinimumW() {\n        return options?.initialInfo?.width && options.minWidth && (options.initialInfo.width < options.minWidth);\n    }\n    function greaterThanMaximumH() {\n        return options?.initialInfo?.height && options.maxHeight && (options.initialInfo.height > options.maxHeight);\n    }\n    function greaterThanMaximumW() {\n        return options?.initialInfo?.width && options.maxWidth && (options.initialInfo.width > options.maxWidth);\n    }\n    function errorSize() {\n        return options.minWidth > options.maxWidth || options.minHeight > options.maxHeight;\n    }\n    function fixMaxAndMin() {\n        const { minWidth, maxWidth, minHeight, maxHeight } = options;\n        if (minWidth > maxWidth) {\n            options.minWidth = maxWidth;\n            options.maxWidth = minWidth;\n        }\n        if (minHeight > maxHeight) {\n            options.minHeight = maxHeight;\n            options.maxHeight = minHeight;\n        }\n    }\n}\nfunction checkOptionPosition(initialInfo) {\n    if (!initialInfo)\n        return;\n    baseWarnTips(posBeNegative(), 'It is not recommended that the initial location information be set to a negative value.');\n    fixInitialPos();\n    fixInitialPos();\n    function fixInitialPos() {\n        initialInfo.top = initialInfo.top > 0 ? initialInfo.top : 0;\n        initialInfo.left = initialInfo.left > 0 ? initialInfo.left : 0;\n    }\n    function posBeNegative() {\n        return initialInfo.left < 0 || initialInfo.top < 0;\n    }\n}\nfunction checkCustomStyle(styles) {\n    if (!styles)\n        return;\n    checkPointStyle(styles.pointStyle);\n    fixPointStyle(styles.pointStyle);\n    checkRefLineStyle(styles.refLineStyle);\n    fixRefLineStyle(styles.refLineStyle);\n    checkTipStyle(styles.tipStyle);\n    fixTipStyle(styles.tipStyle);\n    function checkPointStyle(pointStyle) {\n        if (!pointStyle)\n            return;\n        const unitError = pointStyle?.width && !/^\\d+px$/.test(pointStyle.width)\n            || pointStyle?.height && !/^\\d+px$/.test(pointStyle.height);\n        baseErrorTips(unitError, 'The dimensions of the outline points are supported only in px units.');\n        baseWarnTips(pointStyle?.position && pointStyle.position !== 'absolute', 'PointStyle.position the expected value is absolute and is automatically modified.');\n        baseWarnTips(pointStyle?.display && pointStyle.display !== 'none', `If you do not set the display property of the outline point to none,\r\n      redundant elements may be displayed after the initial rendering is complete.`);\n        baseWarnTips(pointStyle?.boxSizing && pointStyle.boxSizing !== 'border-box', 'If the contour point box-sizing property is not set to border-box, the contour point position may be shifted.');\n    }\n    function checkRefLineStyle(refLineStyle) {\n        baseWarnTips(!isNullOrUndefined(refLineStyle?.width) || !isNullOrUndefined(refLineStyle?.height), 'The guide size cannot be set. It has been moved and deleted.');\n        baseWarnTips(refLineStyle?.position && refLineStyle.position !== 'absolute', 'RefLineStyle.position the expected value is absolute and is automatically modified.');\n        baseWarnTips(refLineStyle?.display && refLineStyle.display !== 'none', `If you do not set the display property of the outline point to none,\r\n      redundant elements may be displayed after the initial rendering is complete.`);\n    }\n    function checkTipStyle(tipStyle) {\n        baseWarnTips(tipStyle?.position && tipStyle.position !== 'absolute', 'TipStyle.position the expected value is absolute and is automatically modified.');\n        baseWarnTips(tipStyle?.display && tipStyle.display !== 'none', `If you do not set the display property of the outline point to none,\r\n      redundant elements may be displayed after the initial rendering is complete.`);\n        baseWarnTips(tipStyle?.boxSizing && tipStyle.boxSizing !== 'border-box', 'If the contour point box-sizing property is not set to border-box, the contour point position may be shifted.');\n    }\n    function fixPointStyle(pointStyle) {\n        if (!pointStyle)\n            return;\n        if (pointStyle?.position)\n            pointStyle.position = 'absolute';\n        if (pointStyle?.display)\n            pointStyle.display = 'none';\n        if (pointStyle?.boxSizing)\n            pointStyle.boxSizing = 'border-box';\n    }\n    function fixRefLineStyle(refLineStyle) {\n        if (!refLineStyle)\n            return;\n        if (refLineStyle?.width)\n            delete refLineStyle.width;\n        if (refLineStyle?.height)\n            delete refLineStyle.height;\n        if (refLineStyle?.position)\n            refLineStyle.position = 'absolute';\n        if (refLineStyle?.display)\n            refLineStyle.display = 'none';\n    }\n    function fixTipStyle(tipStyle) {\n        if (!tipStyle)\n            return;\n        if (tipStyle?.position)\n            tipStyle.position = 'absolute';\n        if (tipStyle?.display)\n            tipStyle.display = 'none';\n        if (tipStyle?.boxSizing)\n            tipStyle.boxSizing = 'border-box';\n    }\n}\n\nclass Draggable {\n    constructor(plugins = new PluginManager, stateManager) {\n        this.plugins = plugins;\n        this.stateManager = stateManager;\n        // 所有被选中的元素的坐标 放到regionalSelection中\n        this.RSStartCoordinate = [];\n        this.start(stateManager.currentState);\n    }\n    start(currentState) {\n        const _this = this;\n        const { pointElements, targetState, containerInfo, publicTarget, downPointPosition, allTarget, privateTarget, drag, dragCallback, coordinate } = currentState;\n        const { limitDragDirection } = currentState.options.skill;\n        // modify the icon for the hover state - 修改悬停状态的图标\n        drag && setStyle(publicTarget.value, 'cursor', 'all-scroll');\n        const { movementX, movementY, isPress, destroy } = useMoveElement(publicTarget.value, {\n            move: this.moveTargetCallback(dragCallback, {\n                downPointPosition, pointElements, targetState, containerInfo\n            }),\n            down: (downAction, event) => {\n                /*\n                * 按下后切换选中的元素\n                * 保存选中元素的的初始位置\n                * 计算所有选中元素轮廓的坐标\n                * 触发插件的dragStart扩展点\n                * regionalSelection 如果按下的是未选中的元素，重置已选中的元素\n                * */\n                downAction();\n                this.stateManager.setCurrentElement(event.target);\n                // 按下的时候记录被区域选中的组件的初始位置\n                saveStartCoordinate();\n                // 计算所有选中元素轮廓的坐标\n                executeComposeCoordinate();\n                this.dragStart({ resetRegionalSelectionData });\n                function executeComposeCoordinate() {\n                    // 如果RSStartCoordinate.length <= 1 说明没有多选元素\n                    if (!_this.stateManager.isRegionSelection)\n                        return;\n                    const left = Math.min(..._this.RSStartCoordinate.map(m => m.left));\n                    const top = Math.min(..._this.RSStartCoordinate.map(m => m.top));\n                    _this.composeCoordinate = {\n                        left,\n                        top,\n                        width: Math.max(..._this.RSStartCoordinate.map(m => m.left + m.width)) - left,\n                        height: Math.max(..._this.RSStartCoordinate.map(m => m.top + m.height)) - top\n                    };\n                }\n                function saveStartCoordinate() {\n                    _this.stateManager.regionSelectedState.forEach(item => {\n                        _this.RSStartCoordinate.push({ ...item.coordinate, el: item.privateTarget });\n                    });\n                }\n            },\n            up: upAction => {\n                upAction();\n                // 清除提供给区域选择框的数据\n                resetRegionalSelectionData();\n                this.dragEnd();\n            }\n        }, { limitDirection: limitDragDirection, offsetLeft: containerInfo.paddingLeft, offsetTop: containerInfo.paddingTop });\n        addGlobalUnmountCb(destroy);\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.watch)(isPress, this.isPressChangeCallback({ pointElements, allTarget, privateTarget }, { targetState }, { downPointPosition, coordinate }, { movementX, movementY }));\n        function resetRegionalSelectionData() {\n            _this.composeCoordinate = null;\n            _this.RSStartCoordinate.length = 0;\n        }\n    }\n    dragStart({ resetRegionalSelectionData }) {\n        // 在拖拽开始时触发扩展点，通知插件\n        this.plugins.callExtensionPoint('dragStart', {\n            composeCoordinate: this.composeCoordinate,\n            publicContainer: this.stateManager.currentState.publicContainer.value,\n            privateTarget: this.stateManager.currentElement,\n            resetRegionalSelectionData\n        });\n    }\n    dragEnd() {\n        this.plugins.callExtensionPoint('dragEnd', { publicContainer: this.stateManager.currentState.publicContainer.value });\n    }\n    moveTargetCallback(dragCallback, { downPointPosition, pointElements, targetState, containerInfo }) {\n        const _this = this;\n        return (moveAction, movement) => {\n            const { coordinate, allTarget, privateTarget } = this.stateManager.currentState;\n            const _updateContourPointPosition = movement => updateContourPointPosition(downPointPosition, movement, pointElements);\n            const _updateState = movement => updateState(targetState, { left: coordinate.left + movement.x, top: coordinate.top + movement.y });\n            // Wrap the action to move the target element as a separate new function, and if the user defines a callback\n            // use moveTargetAction as an argument to that callback\n            // 将移动目标元素的操作包装为单独新的函数,如果用户有定义回调，则将moveTargetAction作为这个回调的参数\n            const moveTargetAction = () => {\n                // perform the default action for movePoint\n                // 执行movePoint的默认动作\n                moveAction();\n                // 限制目标元素在容器内移动\n                this.limitTargetMove(executeCoordinate(), containerInfo, movement);\n                // update the position of the contour points\n                // 更新轮廓点位置\n                _updateContourPointPosition(movement);\n                // update the state of the target element - 更新目标元素状态\n                _updateState(movement);\n                // 同步被多选的其他元素的状态和样式（位置）\n                syncOtherEl(movement);\n                // 获取当前拖拽元素的坐标（多选的情况下需要重新计算坐标，单选直接返回coordinate）\n                function executeCoordinate() {\n                    return _this.stateManager.isRegionSelection ? _this.composeCoordinate : coordinate;\n                }\n            };\n            // Hand over control (moveTargetAction)\n            // 将控制权（moveTargetAction）交出\n            transferControl(moveTargetAction, dragCallback, { movementX: movement.x, movementY: movement.y });\n            this.plugins.callExtensionPoint('drag', { allTarget, privateTarget }, { movement, _updateContourPointPosition, _updateState, syncOtherEl });\n            // 需要更新其他元素位置和状态\n            function syncOtherEl(movement) {\n                // 多选的情况下才需要做同步操作\n                if (_this.stateManager.isRegionSelection) {\n                    // 更新其余被区域选中的元素样式\n                    updateOtherElStyle();\n                    // 更新其余被区域选中的元素状态\n                    updateOtherElState();\n                }\n                function updateOtherElStyle() {\n                    _this.stateManager.regionSelectedElement.forEach(el => {\n                        if (el === _this.stateManager.currentElement)\n                            return;\n                        const startCoordinate = _this.RSStartCoordinate.find(item => item.el === el);\n                        if (startCoordinate)\n                            setStyle(el, numberToStringSize({\n                                left: startCoordinate.left + movement.x,\n                                top: startCoordinate.top + movement.y\n                            }));\n                    });\n                }\n                function updateOtherElState() {\n                    _this.stateManager.regionSelectedState.forEach(state => {\n                        if (state.privateTarget === _this.stateManager.currentElement)\n                            return;\n                        const startCoordinate = _this.RSStartCoordinate.find(item => item.el === state.privateTarget);\n                        if (startCoordinate) {\n                            _this.stateManager.setStateByEle(state.privateTarget, 'coordinate', { ...state.coordinate, left: startCoordinate.left + movement.x, top: startCoordinate.top + movement.y });\n                        }\n                    });\n                }\n            }\n        };\n    }\n    // 限制容器内移动\n    limitTargetMove(coordinate, containerInfo, movement) {\n        const { left, top, width: targetWidth, height: targetHeight } = coordinate;\n        const { width: containerWidth, height: containerHeight, paddingTop, paddingLeft } = containerInfo;\n        arriveLeft() && (movement.x = -left);\n        arriveTop() && (movement.y = -top);\n        arriveRight() && (movement.x = containerWidth + paddingLeft - targetWidth - left);\n        arriveBottom() && (movement.y = containerHeight + paddingTop - targetHeight - top);\n        // containerWidth + offsetLeft, containerHeight + offsetTop 是计算过容器元素相对body偏移之后的位置\n        function arriveLeft() {\n            return movement.x + left <= 0;\n        }\n        function arriveRight() {\n            return movement.x + left + targetWidth >= containerWidth + paddingLeft;\n        }\n        function arriveTop() {\n            return movement.y + top <= 0;\n        }\n        function arriveBottom() {\n            return movement.y + top + targetHeight >= containerHeight + paddingTop;\n        }\n    }\n    targetMouseDown({ downPointPosition, pointElements }) {\n        saveDownPointPosition({ downPointPosition, pointElements });\n    }\n    targetMouseUp({ coordinate, movementX, movementY }) {\n        // mouse up to update the coordinates of the target element\n        // 鼠标抬起时更新目标元素的坐标数据\n        updateInitialTarget(coordinate, { top: coordinate.top + movementY.value, left: coordinate.left + movementX.value });\n    }\n    isPressChangeCallback({ pointElements, allTarget, privateTarget }, { targetState }, { downPointPosition, coordinate }, { movementX, movementY }) {\n        return (newV) => {\n            updateState(targetState, 'isPress', newV);\n            if (newV) {\n                this.targetMouseDown({ downPointPosition, pointElements });\n            }\n            else {\n                this.targetMouseUp({ coordinate, movementX, movementY });\n            }\n            this.plugins.callExtensionPoint('targetPressChange', newV, { allTarget, privateTarget });\n        };\n    }\n}\n\nclass Resizeable {\n    constructor(plugins = new PluginManager(), stateManager) {\n        this.plugins = plugins;\n        this.stateManager = stateManager;\n        this.standardStrategies = {\n            max(...rest) { return Math.max(...rest); },\n            min(...rest) { return Math.min(...rest); }\n        };\n        this.init(stateManager.currentState);\n    }\n    init(initState) {\n        const { coordinate, allTarget, privateTarget, publicTarget, pointElements, pointState, options } = initState;\n        const pointPosition = createParentPosition(coordinate, options.pointSize);\n        this.initContourPoints({ publicTarget, pointElements, allTarget, privateTarget }, { pointState }, { coordinate }, options, { pointPosition });\n    }\n    // 初始化轮廓点\n    initContourPoints({ publicTarget, pointElements, allTarget, privateTarget }, { pointState }, { coordinate }, options, runtimeParameter) {\n        const { pointPosition } = runtimeParameter;\n        const { pointSize, customClass: { customPointClass }, customStyle: { pointStyle } } = options;\n        for (const direction in pointPosition) {\n            const point = this.createContourPoint(pointElements, direction);\n            this.initPointStyle(point, { pointPosition, direction: direction, pointSize }, pointStyle);\n            addClassName(point, customPointClass);\n            addClassName(point, direction);\n            appendChild(publicTarget.value.parentNode, point);\n            const isPress = this.addDragFunctionToPoint(publicTarget, options, { point, pointPosition, direction });\n            // update the width and height information when releasing the mouse - 当释放鼠标时更新宽度和高度信息\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.watch)(isPress, this.pointIsPressChangeCallback(publicTarget.value, { coordinate, pointState, direction, allTarget, privateTarget }));\n        }\n    }\n    pointIsPressChangeCallback(target, { coordinate, pointState, direction, allTarget, privateTarget }) {\n        return newV => {\n            const currentTarget = this.stateManager.currentElement;\n            // 与window绑定mousedown同理，取消无用更新\n            if (target !== currentTarget)\n                return;\n            pointState.isPress = newV;\n            pointState.direction = direction;\n            if (!newV) {\n                pointState.direction = null;\n                updateInitialTarget(coordinate, getCoordinateByElement(target));\n            }\n            // MARK 通知插件鼠标状态更新\n            this.plugins.callExtensionPoint('pointPressChange', newV, { allTarget, privateTarget });\n        };\n    }\n    // initializes the style of the contour points\n    // 初始化轮廓点的样式\n    initPointStyle(point, { pointPosition, direction, pointSize }, pointDefaultStyle) {\n        pointDefaultStyle && setStyle(point, pointDefaultStyle);\n        setStyle(point, 'width', pointSize + 'px');\n        setStyle(point, 'height', pointSize + 'px');\n        setStyle(point, 'cursor', pointPosition[direction][2]);\n        setPosition(point, pointPosition, direction);\n    }\n    // 为轮廓点添加拖拽功能\n    addDragFunctionToPoint(publicTarget, options, runTimeParameter) {\n        const { point, pointPosition, direction } = runTimeParameter;\n        const { resizeCallback } = options.callbacks || {};\n        const { isPress, movementX, movementY } = useMoveElement(point, (moveAction, _, event) => {\n            const moveResizeAction = () => {\n                this.movePointCallback({ direction, movementX, movementY, moveAction, target: publicTarget.value });\n            };\n            // Hand over control (moveResizeAction) - 将控制权（moveResizeAction）交出\n            transferControl(moveResizeAction, resizeCallback, direction, { movementX: movementX.value, movementY: movementY.value }, event);\n        }, { limitDirection: pointPosition[direction][3] });\n        return isPress;\n    }\n    movePointCallback({ moveAction, target, direction, movementX, movementY }) {\n        const { coordinate, containerInfo, targetState, pointState, pointElements, allTarget, privateTarget, options: { minWidth, minHeight, maxWidth, maxHeight, pointSize } } = this.stateManager.getStateByEle(target);\n        moveAction();\n        const _updateTargetStyle = ({ movementX, movementY }) => {\n            updateTargetStyle(target, { direction, movementX, movementY }, { targetState, coordinate });\n        };\n        const _updatePointPosition = ({ movementX, movementY }) => {\n            updatePointPosition({ direction, movementX, movementY }, { coordinate, pointElements, pointSize, pointState });\n        };\n        limitTargetResize(target, { direction, movementX, movementY }, { coordinate, containerInfo, minWidth, minHeight, maxWidth, maxHeight });\n        _updateTargetStyle({ movementX: movementX.value, movementY: movementY.value });\n        _updatePointPosition({ movementX: movementX.value, movementY: movementY.value });\n        this.plugins.callExtensionPoint('resize', { allTarget, privateTarget }, { movementX, movementY, _updateTargetStyle, _updatePointPosition });\n    }\n    /**\n     * 等比缩放\n     * @param movementX x轴移动的距离\n     * @param movementY y轴移动的距离\n     * @param width resize开始前的宽度\n     * @param height resize开始前的高度\n     * @param ratio 比例\n     * @param direction 轮廓点标识\n     * @param standard 基准模式\n     * MARK 等比缩放需要修改createCoordinateStrategies，使单方向缩放时，可以更新另一个方向的尺寸\n     */\n    sameRatio({ movementX, movementY, width, height }, { ratio, direction }, standard = 'max') {\n        const maxV = Math.max(movementX.value, movementY.value);\n        const isX = maxV === movementX.value;\n        const singleDireX = ['l', 'r'].includes(direction); // 单方向横向拖动\n        const singleDireY = ['t', 'b'].includes(direction); // 单方向纵向拖动\n        if (singleDireX) {\n            const newHeight = (width + movementX.value) / ratio;\n            movementY.value = newHeight - height;\n        }\n        else if (singleDireY) {\n            const newWidth = (height + movementY.value) * ratio;\n            movementX.value = newWidth - width;\n        }\n        else {\n            const newHeight = conditionExecute(isX, (width + movementX.value) / ratio, width + movementX.value);\n            const newWidth = conditionExecute(!isX, (height + movementY.value) * ratio, height + movementY.value);\n            conditionExecute(isX, movementY.value = newHeight - height, movementX.value = newWidth - width);\n        }\n    }\n    createContourPoint(pointElements, direction) {\n        return pointElements[direction] || (pointElements[direction] = document.createElement('div'));\n    }\n}\n\nclass Coordinate {\n    constructor() {\n        this.left = 0;\n        this.top = 0;\n        this.width = 0;\n        this.height = 0;\n        this.id = generateID();\n    }\n    get isCoordinate() {\n        return true;\n    }\n}\nclass BuildState {\n    constructor() {\n        this._publicState = createPublicState();\n        this._privateState = createPrivateState();\n    }\n    get publicState() {\n        return this._publicState;\n    }\n    get privateState() {\n        return this._privateState;\n    }\n    static createCoordinate() {\n        return new Coordinate();\n    }\n}\nfunction createPrivateState() {\n    return {\n        privateTarget: null,\n        coordinate: new Coordinate(),\n        regionSelected: false,\n        isComposed: false,\n        id: generateID()\n    };\n}\nfunction createPublicState() {\n    return {\n        allTarget: [],\n        allContainer: [],\n        publicTarget: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(null),\n        publicContainer: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(null),\n        pointElements: null,\n        containerInfo: null,\n        downPointPosition: null,\n        targetState: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)({\n            left: 0,\n            top: 0,\n            height: 0,\n            width: 0,\n            isPress: false\n        }),\n        pointState: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)({\n            left: 0,\n            top: 0,\n            direction: null,\n            isPress: false,\n            movementX: 0,\n            movementY: 0\n        })\n    };\n}\n\n// @ts-ignore\nwindow.stateManager = stateManager;\n/*\n* TODO\n*  15.使用 key 的映射表来保存坐标、尺寸等信息\n*  18.目标元素的 left、top 应该是相对容器计算\n*  23.等比缩放 (需要修改 createCoordinateStrategies 方法)\n*  26.通过调用API的方式来处理配置信息\n*  27.style类控制样式\n*  29.重构创建初始状态的代码\n*  32.多选的吸附可能会超出边界\n*  34.regionStyle、selectedStyle 参数检查\n*  35.完成insertElement API\n* */\n// default configuration\n// 默认配置\nlet { allTarget, allContainer, publicTarget, publicContainer, pointElements, containerInfo, downPointPosition, targetState, pointState, } = new BuildState().publicState;\nfunction initGlobalData() {\n    publicTarget.value = null;\n    publicContainer.value = null;\n    updateInitialTarget();\n    pointElements = pointElements || {};\n    containerInfo = {};\n    downPointPosition = {};\n    Object.assign(targetState, { left: 0, top: 0, height: 0, width: 0, isPress: false, isLock: false });\n    Object.assign(pointState, { left: 0, top: 0, direction: null, isPress: false, movementX: 0, movementY: 0 });\n}\nconst offsetCache = new Map();\nfunction useMagicDragAPI(targetSelector, options) {\n    const { containerSelector } = options;\n    const privateState = new BuildState().privateState;\n    // 初始化全局数据\n    initGlobalData();\n    initGlobalStyle();\n    // 显示或隐藏轮廓点的方法\n    const processBlurOrFocus = blurOrFocus(pointElements, targetState, stateManager);\n    // 每次都是获取到一个新闭包，需要单独保存\n    addGlobalUnmountCb(processBlurOrFocus.bind(null, publicTarget.value, false));\n    nextTick(readyMagicDrag);\n    function readyMagicDrag() {\n        initContainer();\n        initTarget();\n        // 注册元素状态的同时将元素设置为选中元素（初始化Draggable和Resizeable时需要使用）\n        setInitialState(publicTarget.value, initialState(), true);\n        enableDragFunc();\n        enableResizeFunc();\n        // 处理点击目标元素显示/隐藏轮廓点的逻辑\n        processBlurOrFocus(publicTarget.value);\n    }\n    // initializes the container element - 初始化容器元素\n    function initContainer() {\n        saveContainerEl();\n        enableContainerGrid();\n        guaranteeOpenPosition();\n        saveContainerSizeAndOffset(contentAreaSize(), contentAreaOffset());\n        function saveContainerEl() {\n            publicContainer.value = getElement(containerSelector);\n            allContainer.push(publicContainer.value);\n        }\n        // 容器尺寸信息\n        function contentAreaSize() {\n            const { paddingLeft, paddingRight, paddingTop, paddingBottom, width, height, boxSizing, borderLeftWidth, borderRightWidth, borderTopWidth, borderBottomWidth } = getComputedStyle(publicContainer.value);\n            return { containerWidth: containerWidth(), containerHeight: containerHeight() };\n            function isBorderBox() {\n                return boxSizing === 'border-box';\n            }\n            function containerHeight() {\n                return isBorderBox()\n                    ? parseInt(height) - parseInt(paddingTop) - parseInt(paddingBottom) - parseInt(borderBottomWidth) - parseInt(borderTopWidth)\n                    : parseInt(height);\n            }\n            function containerWidth() {\n                return isBorderBox()\n                    ? parseInt(width) - parseInt(paddingLeft) - parseInt(paddingRight) - parseInt(borderLeftWidth) - parseInt(borderRightWidth)\n                    : parseInt(width);\n            }\n        }\n        // 容器相对body内容左上角的偏移量（如果容器元素的父级不是body可能出现问题）\n        function contentAreaOffset() {\n            if (offsetCache.has(publicContainer.value))\n                return offsetCache.get(publicContainer.value);\n            const { paddingLeft = '0', paddingTop = '0' } = getComputedStyle(publicContainer.value);\n            const bodyRect = document.body.getBoundingClientRect();\n            const containerRect = publicContainer.value.getBoundingClientRect();\n            offsetCache.set(publicContainer.value, {\n                paddingLeft: parseInt(paddingLeft),\n                paddingTop: parseInt(paddingTop),\n                relBodyOffsetLeft: containerRect.left - bodyRect.left,\n                relBodyOffsetTop: containerRect.top - bodyRect.top\n            });\n            // 如果开启定位，返回偏移量\n            return offsetCache.get(publicContainer.value);\n        }\n        function saveContainerSizeAndOffset({ containerWidth, containerHeight }, { paddingLeft, paddingTop, relBodyOffsetLeft, relBodyOffsetTop }) {\n            containerInfo.width = containerWidth;\n            containerInfo.height = containerHeight;\n            containerInfo.paddingLeft = paddingLeft;\n            containerInfo.paddingTop = paddingTop;\n            containerInfo.relBodyOffsetLeft = relBodyOffsetLeft;\n            containerInfo.relBodyOffsetTop = relBodyOffsetTop;\n        }\n        // 如果容器元素未开启定位，给它开启相对定位\n        function guaranteeOpenPosition() {\n            const { position } = getComputedStyle(publicContainer.value);\n            if (['relative', 'absolute', 'fixed'].includes(position))\n                publicContainer.value.style.position = 'relative';\n        }\n    }\n    // initializes the target element - 初始化目标元素\n    function initTarget() {\n        // 保存目标元素的引用\n        saveTargetEl();\n        baseErrorTips(!publicTarget.value, 'targetSelector is an invalid selector or HTMLElement');\n        // 保存目标元素的信息和绑定事件\n        saveAndBindTargetData();\n        // 初始化目标元素样式信息\n        initTargetStyle(publicTarget.value, posRelativeToContainer().size, posRelativeToContainer().position);\n        // 初始化\n        saveInitialData(publicTarget.value, privateState.coordinate);\n        // 初始化结束后更新状态\n        updateState(targetState, privateState.coordinate);\n        // 计算相对容器的尺寸信息\n        function posRelativeToContainer() {\n            const left = options.initialInfo.left + containerInfo.paddingLeft;\n            const top = options.initialInfo.top + containerInfo.paddingTop;\n            return { position: { left, top }, size: { width: options.initialInfo.width, height: options.initialInfo.height } };\n        }\n        function saveTargetEl() {\n            privateState.privateTarget = publicTarget.value = getElement(targetSelector);\n            allTarget.push(publicTarget.value);\n        }\n        function saveAndBindTargetData() {\n            publicTarget.value.addEventListener('mousedown', updateTargetPointTo);\n            publicTarget.value.dataset.index = String(allTarget.length);\n        }\n    }\n    return {\n        targetLeft: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(() => targetState.left - stateManager.containerLeft),\n        targetTop: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(() => targetState.top - stateManager.containerTop),\n        targetWidth: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(targetState, 'width'),\n        targetHeight: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(targetState, 'height'),\n        targetIsPress: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(targetState, 'isPress'),\n        targetIsLock: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(targetState, 'isLock'),\n        pointLeft: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(() => getPointValue(pointState, 'left')),\n        pointTop: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(() => getPointValue(pointState, 'top')),\n        direction: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(pointState, 'direction'),\n        pointIsPress: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(pointState, 'isPress'),\n        pointMovementX: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(pointState, 'movementX'),\n        pointMovementY: (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(pointState, 'movementY'),\n        getStateList() {\n            return stateManager.elementRecords.map(m => m.state);\n        },\n        getTargetState() {\n            return stateManager.currentState;\n        },\n        unMount\n    };\n    function unMount() {\n        // 卸载全局监听等\n        unMountGlobalCb();\n        // 解绑所有插件\n        pluginManager.uninstallPlugin();\n        // 页面卸载时销毁 dom 元素\n        removeElements(pointElements);\n        // 移除所有目标元素的监听事件\n        removeListener();\n        // 清除状态信息\n        stateManager.clear();\n        // 重置公共数据\n        resetPublicData();\n        function removeListener() {\n            stateManager.elementRecords\n                .map(m => m.element)\n                .forEach(el => el.removeEventListener('mousedown', updateTargetPointTo));\n        }\n    }\n    function updateTargetPointTo(event) {\n        publicTarget.value = event.target;\n    }\n    function initialState() {\n        return {\n            allTarget, allContainer,\n            publicTarget, publicContainer, pointElements, containerInfo, downPointPosition,\n            targetState, pointState,\n            ...privateState, options\n        };\n    }\n    function resetPublicData() {\n        allContainer.length = 0;\n        allTarget.length = 0;\n    }\n    function enableDragFunc() {\n        options.skill.drag && new Draggable(pluginManager, stateManager);\n    }\n    function enableResizeFunc() {\n        options.skill.resize && new Resizeable(pluginManager, stateManager);\n    }\n    function initGlobalStyle() {\n        options.containerSelector === 'body' && fixContourExceed();\n    }\n    function enableContainerGrid() {\n        options.grid && setContainerGrid();\n        function setContainerGrid() {\n            setStyle(publicContainer.value, {\n                background: 'white',\n                backgroundImage: `linear-gradient(90deg,rgba(241,243,244,1) 10%,transparent 0),\r\n        linear-gradient(rgba(241,243,244,1) 10%,transparent 0)`,\n                backgroundSize: '10px 10px'\n            });\n        }\n    }\n}\n\nfunction preventMistakeParameter(parameter) {\n    parameter.forEach(item => {\n        if (!notSelectorAndHTML(item))\n            return;\n        // @ts-ignore\n        item.initialSize = item.initialSize || {};\n        // @ts-ignore\n        item.initialPosition = item.initialPosition || {};\n    });\n}\nfunction formatSelectors(targetSelectors) {\n    const selectors = [];\n    const initialInfos = [];\n    targetSelectors.forEach(magicSel => {\n        if (typeof magicSel === 'object') {\n            selectors.push(magicSel.selector);\n            // @ts-ignore\n            initialInfos.push(mergeObject({}, { ...magicSel.initialPosition, ...magicSel.initialSize }));\n            return;\n        }\n        selectors.push(magicSel);\n        initialInfos.push({});\n    });\n    return { selectors, initialInfos };\n}\nfunction useMagicList(targetSelectors, options) {\n    preventMistakeParameter(targetSelectors);\n    const { selectors, initialInfos } = formatSelectors(targetSelectors);\n    initialInfos.forEach(initialInfo => checkOptionSize({\n        initialInfo,\n        maxHeight: options?.maxHeight ?? defaultOptions().maxHeight,\n        minHeight: options?.minHeight ?? defaultOptions().minHeight,\n        maxWidth: options?.maxWidth ?? defaultOptions().maxWidth,\n        minWidth: options?.minWidth ?? defaultOptions().minWidth\n    }));\n    const hasCorrectType = selectors.some(selector => notSelectorAndHTML(selector));\n    baseErrorTips(hasCorrectType, `targetSelectors receive an array of tag selectors or HTML elements,\r\n\t\tbut the passed targetSelectors contain the value of the unexpected type`);\n    checkParameterType(defaultOptions(), options);\n    checkParameterValue(options);\n    options = tidyOptions(mergeObject(defaultOptions(), options));\n    usePlugin(options);\n    baseErrorTips(options.customClass.customPointClass.startsWith(MAGIC_DRAG), `custom class names cannot start with ${MAGIC_DRAG}, please change your class name`);\n    let state;\n    selectors.forEach((selector, index) => {\n        state = useMagicDragAPI(selector, mergeObject(options, { initialInfo: initialInfos[index] }));\n    });\n    // 参数检查\n    function insertElement(selector) {\n        if (typeof selector === 'string' || selector instanceof HTMLElement)\n            return useMagicDragAPI(selector, options);\n        if (typeof selector === 'object') {\n            const initialInfo = { ...selector.initialSize, ...selector.initialPosition };\n            checkOptionSize(mergeObject(options, initialInfo));\n            return useMagicDragAPI(selector.selector, { ...options, initialInfo });\n        }\n    }\n    state.insertElement = insertElement;\n    return state;\n}\nfunction useMagicDrag(targetSelector, options) {\n    return useMagicList([targetSelector], options);\n}\n\n\n\n\n//# sourceURL=webpack://github.io.demo/./node_modules/_magic_drag@1.2.7@magic_drag/lib/magic_drag-esm.js?");

/***/ })

}]);