## dragResize

~~已完成~~

### useDragResize  引入添加哪些功能

 - 边界限制：允许指定目标元素的拖拽和调整大小的边界范围，以防止超出指定区域。
 - 比例限制：允许指定目标元素的宽高比例限制，以保持其宽高比例不变。
 - 回调函数：提供回调函数的选项，允许在拖拽或调整大小时执行自定义逻辑，例如更新数据、发送请求等。
 - 事件处理：暴露目标元素的拖拽和调整大小的事件，以便外部组件可以监听并作出相应的处理。
 - 其他交互特性：例如，支持双击重置大小、右键菜单、拖拽时的半透明效果等。
 - 这些是一些可以考虑添加到 useDragResize 中的功能。根据你的具体需求和项目要求，选择适合的功能来增强钩子函数的功能性和灵活性。
 - 容器限制：或者新增useMoveContainer实现该功能
 - 代码结构优化
 - 类型注解
 - ~~错误处理~~

### 优化策略对象

 - 代码结构优化：对于策略对象的定义和使用，可以考虑将其放在钩子函数的外部，作为模块级别的常量或变量。这样可以提高代码的可读性和可维护性，并使钩子函数更加简洁。
 - 函数化重构：将策略对象中的属性和方法转化为纯函数，而不是对象中的方法。这样可以消除对对象的依赖，提高函数的可测试性和可复用性。
 - 抽象和通用化：对于不同的策略，可以考虑将其抽象为通用的函数，以便在多个地方复用。这样可以减少重复代码，提高代码的可维护性和可扩展性。
 - 配置化选项：将策略对象中的硬编码值提取为可配置的选项，允许用户根据需要进行自定义。这样可以增加钩子函数的灵活性，使其适用于更多的场景。
 - 性能优化：对于计算密集型的策略，可以考虑使用缓存或优化算法来提高性能。例如，使用记忆化技术缓存计算结果，避免重复计算。

### 综合useMovePoint和useDragResize

 - 代码复用：将两个钩子函数的共用逻辑提取出来，形成一个单独的可复用的函数或组合函数。这样可以避免重复编写相似的代码，提高代码的可维护性和可读性。
 - 性能优化：在 useMovePoint 中，可以考虑添加一些性能优化的措施，例如使用节流或防抖函数来控制回调函数的执行频率，避免过多的计算或渲染操作。
 - 选项配置：对于 useMovePoint 和 useDragResize，可以提供更多的选项配置，以满足不同的使用场景和需求。例如，可以添加配置项来控制是否禁用移动或调整大小的功能，设置边界限制条件等。
 - 错误处理：在钩子函数中添加错误处理机制，例如对传入的参数进行校验和容错处理，避免出现意外错误导致应用崩溃或产生不可预料的行为。
 - 事件处理：在钩子函数中，对于事件的绑定和解绑可以更加灵活和可控。可以考虑使用 onUnmounted 钩子来自动解绑事件，避免内存泄漏和无效的事件监听。
 - 文档和示例：提供清晰的文档和示例，说明如何正确使用这两个钩子函数，并给出一些最佳实践和使用示例，以便开发者能够更好地理解和使用这些功能。
 - 拖拽与缩放模式切换：为 useDragResize 添加一个模式切换的功能，允许用户在拖拽和调整大小之间进行切换。这样可以提供更多灵活性，适应不同的使用场景和需求。
 - 事件处理的解耦：将事件处理逻辑从钩子函数中解耦出来，使钩子函数只关注元素的状态和属性管理，而将具体的事件处理逻辑交给使用者自定义。这样可以提高钩子函数的灵活性和可扩展性。
 - 拖拽效果优化：在拖拽过程中，可以添加一些过渡效果或动画，使拖拽操作更加平滑和自然。可以利用 Vue 的过渡系统或 CSS 动画来实现这些效果。
 - 事件委托：对于轮廓点的事件处理，可以考虑使用事件委托的方式，将事件监听添加到父元素上，而不是每个轮廓点都添加监听器。这样可以减少事件处理的数量，提高性能和可维护性。

### useMoveContainer

> 我想写一个useMoveContainer钩子，它的功能是这样的：可以向这个钩子传入一个数组，数组的每一个元素都是一个dom元素，
> 结合useMovePoint和useDragResize函数使其可以拖拽，但可拖拽的区域仅限制在这个容器内部.

 - 接收容器元素：作为参数，useMoveContainer 钩子应该接收一个数组，数组的每个元素都是要作为容器的 DOM 元素。可以使用 ref 或 toRefs 来包装容器元素，并确保在更新容器元素时能够触发响应。
 - 循环遍历容器元素：对于每个容器元素，应用 useMovePoint 和 useDragResize 钩子函数，使其具备拖拽和调整大小的功能。可以使用 v-for 或 Array.map 方法来循环遍历容器元素数组，并将钩子函数应用到每个元素上。
 - 限制拖拽范围：在 useMoveContainer 中，需要限制拖拽的范围在容器内部。可以通过计算容器元素的边界信息（左上角和右下角坐标）以及拖拽元素的位置信息来判断和限制拖拽的范围。在 useMovePoint 中，可以根据容器元素的位置和大小信息，将拖拽范围限制在容器内部。
 - 事件委托和事件处理：对于拖拽和调整大小的事件处理，可以考虑使用事件委托的方式，将事件监听添加到容器元素上，而不是每个子元素都添加监听器。这样可以减少事件处理的数量，提高性能和可维护性。
 - 样式和效果：可以为容器元素和拖拽元素添加样式和过渡效果，使拖拽操作更加可视化和流畅。可以根据具体需求使用 CSS 或动画库来实现这些效果。
 - 事件回调和状态管理：在 useMoveContainer 钩子中，可以提供回调函数或响应式的状态，用于通知外部元素的位置和大小变化。可以通过事件回调或监听响应式状态的变化来获取更新后的位置和大小信息。
 - 性能优化和代码调试：在编写钩子函数的过程中，要注意性能优化，避免不必要的计算和渲染。同时，使用调试工具和日志输出来帮助调试和定位问题。

### 
~~拖动和调整大小的边界限制：目前useDragResize支持设置最小宽度和高度的限制，但可以进一步添加边界限制功能，例如最大宽度和高度的限制，以及在父容器内拖动和调整大小的限制。~~
自定义样式和类名：允许用户传入自定义的样式和类名，以便用户可以自定义轮廓点和目标元素的样式。
拖动和调整大小的步长：允许用户设置拖动和调整大小的步长，以便更精确地控制拖动和调整大小的效果。
拖动和调整大小的动画效果：为拖动和调整大小添加动画效果，使得目标元素的移动和尺寸变化更平滑。
对齐和吸附功能：在拖动和调整大小时，添加对齐和吸附功能，使得目标元素可以自动对齐到其他元素或网格线。
自定义拖动和调整大小的触发条件：目前useDragResize使用鼠标按下即可触发拖动和调整大小，可以考虑添加更灵活的触发条件，如按下特定按键时触发、或者通过手势触发。
多个目标元素支持：目前useDragResize仅支持一个目标元素，可以考虑添加支持同时操作多个目标元素的功能。
~~拖动和调整大小的回调事件：添加拖动和调整大小时的回调事件，使得用户可以在特定事件发生时执行自定义逻辑。~~

